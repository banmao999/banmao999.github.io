{"meta":{"title":"半猫的小站","subtitle":"呜啦啦啦啦啦啦啊","description":"一个小小的学习屋","author":"半猫","url":"http://yoursite.com","root":"/"},"pages":[{"title":"自我埋汰的简介","date":"2019-04-07T09:07:37.000Z","updated":"2020-07-07T15:12:13.947Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这是一个正在学习前端和后端的菜鸟回忆录 我会将所有的笔记放在这里，估计只有我自己看吧~~"},{"title":"分类","date":"2020-07-07T15:01:48.000Z","updated":"2020-07-07T15:13:04.879Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"站点地图","date":"2020-07-07T15:08:20.000Z","updated":"2020-07-07T15:13:25.967Z","comments":true,"path":"sitemap/index.html","permalink":"http://yoursite.com/sitemap/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-07T15:04:58.000Z","updated":"2020-07-07T15:13:15.455Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"4-组件化开发","slug":"4-组件化","date":"2020-08-30T04:37:24.000Z","updated":"2020-08-30T14:43:29.250Z","comments":true,"path":"2020/08/30/4-组件化/","link":"","permalink":"http://yoursite.com/2020/08/30/4-%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"","text":"组件化开发VUE的组件化思想组件化是Vue.js中的重要思想 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。 任何的应用都会被抽象成一颗组件树。 组件化思想的应用： 有了组件化的思想，我们在之后的开发中就要充分的利用它。 尽可能的将页面拆分成一个个小的、可复用的组件。 这样让我们的代码更加方便组织和管理，并且扩展性也更强。 注册组件的基本步骤组件的使用分成三个步骤： 创建组件构造器：调用 Vue.extend() 方法 注册组件：调用 Vue.component() 方法 使用组件：在Vue实例的作用范围内使用组件","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"3-基础语法2","slug":"3-基础语法2","date":"2020-08-28T04:37:24.000Z","updated":"2020-09-05T05:49:45.226Z","comments":true,"path":"2020/08/28/3-基础语法2/","link":"","permalink":"http://yoursite.com/2020/08/28/3-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%952/","excerpt":"基础语法事件监听v-on 作用：绑定事件监听器 缩写：@ 预期：Function | Inline Statement | Object 参数：event 123456789101112131415161718192021&lt;div id=\"app\"&gt; 点击次数：&#123;&#123;counter&#125;&#125; &lt;button v-on:click=\"btnClick\"&gt; 按钮点击 &lt;/button&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; btnClick() &#123; this.counter++ &#125; &#125; &#125;)&lt;/script&gt; 语法糖： 123456&lt;div id=\"app\"&gt; 点击次数：&#123;&#123;counter&#125;&#125; &lt;button @click=\"btnClick\"&gt; 按钮点击 &lt;/button&gt;&lt;/div&gt;","text":"基础语法事件监听v-on 作用：绑定事件监听器 缩写：@ 预期：Function | Inline Statement | Object 参数：event 123456789101112131415161718192021&lt;div id=\"app\"&gt; 点击次数：&#123;&#123;counter&#125;&#125; &lt;button v-on:click=\"btnClick\"&gt; 按钮点击 &lt;/button&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; btnClick() &#123; this.counter++ &#125; &#125; &#125;)&lt;/script&gt; 语法糖： 123456&lt;div id=\"app\"&gt; 点击次数：&#123;&#123;counter&#125;&#125; &lt;button @click=\"btnClick\"&gt; 按钮点击 &lt;/button&gt;&lt;/div&gt; v-on参数当通过methods中定义方法，以供@click调用时，需要注意参数问题： 情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。 ​ 但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去 情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。 12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; 点击次数：&#123;&#123;counter&#125;&#125; &lt;button @click=\"btnClick1\"&gt;按钮点击1&lt;/button&gt; &lt;button @click=\"btnClick2(10, $event)\"&gt; 按钮点击2 &lt;/button&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; btnClick1(event) &#123; this.counter++; &#125;, btnClick2(count, event) &#123; this.counter += 10; &#125; &#125; &#125;)&lt;/script&gt; v-on修饰符在某些情况下，我们拿到event的目的可能是进行一些事件处理。 Vue提供了修饰符来帮助我们方便的处理一些事件： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 1234567891011121314151617181920&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=\"Function\"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=\"Function\"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=\"Function\"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;button @keyup.enter=\"Function\"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;button @keyup.13=\"Function\"&gt;&lt;/button&gt;&lt;!-- 点击回调只触发一次 --&gt;&lt;button @click.once=\"Function\"&gt;&lt;/button&gt; 条件判断v-if、v-else-if、v-else这三个指令与JavaScript的条件语句if、else、else if类似。 Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件 v-if的原理： v-if后面的条件为false时，对应的元素以及其子元素不会渲染。 也就是根本没有不会有对应的标签出现在DOM中。 12345678910111213141516&lt;div id=\"app\"&gt; &lt;p v-if=\"score&gt;=90\"&gt;优秀&lt;/p&gt; &lt;p v-else-if=\"score&gt;=80\"&gt;良好&lt;/p&gt; &lt;p v-else-if=\"score&gt;=60\"&gt;及格&lt;/p&gt; &lt;p v-else&gt;不及格&lt;/p&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; score: 91 &#125; &#125;)&lt;/script&gt; 当逻辑表达式较复杂时，建议使用computed属性 v-showv-show的用法和v-if非常相似，也用于决定一个元素是否渲染 v-if和v-show对比： v-if当条件为false时，压根不会有对应的元素在DOM中。 v-show当条件为false时，仅仅是将元素的display属性设置为none而已。 开发中如何选择呢？ 当需要在显示与隐藏之间切片很频繁时，使用v-show 当只有一次切换时，通过使用v-if 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;button @click=\"toggle\"&gt;切换显示&lt;/button&gt; &lt;h2 v-show=\"isShow\"&gt; 是否显示 &lt;/h2&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; isShow: true; &#125;, methosd: &#123; toggle() &#123; this.isShow = !this.isShow; &#125; &#125; &#125;)&lt;/script&gt; 循环遍历v-for遍历数组v-for的语法类似于JavaScript中的for循环。 格式如下：item in items的形式。 如果在遍历的过程中不需要使用索引值 v-for=”movie in movies” 依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie 如果在遍历的过程中，需要拿到元素在数组中的索引值 语法格式：v-for=(item, index) in items 其中的index就代表了取出的item在原数组的索引值。 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in movies\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;hr&gt; &lt;li v-for=\"(movie, index) in movies\"&gt; &#123;&#123;index+1&#125;&#125;, &#123;&#123;movie&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; movies: [ '电影1', '电影2', '电影3', '电影4' ] &#125; &#125;)&lt;/script&gt; v-for遍历对象v-for可以用户遍历对象： 比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来。 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key, index) in info\"&gt; &#123;&#123;value&#125;&#125; - &#123;&#123;key&#125;&#125; - &#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; info: &#123; name: '张三', age: 18, height: 1.90 &#125; &#125; &#125;)&lt;/script&gt; 响应式的数组方法因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。 Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。 push() pop() shift() unshift() splice() sort() reverse() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in letters\"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click='btnClick'&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; letters: ['1', '2', '3', '4', '5'] &#125; methods: &#123; btnClick() &#123; // 1.push方法 在最后添加新元素 this.letters.push('6'); // 2.pop() 删除数组中最后一个的元素 this.letters.pop(); // 3.shift() 删除数组中第一个元素 this.letters.shift(); // 4.unshift() 在数组最前面添加新元素 this.letters.unshift(); // 5.splice(start. ) // 第一个参数：start 表示数组操作的起始位置 // 第二个参数: NUM 根据操作类型不同而定 // 删除元素：第二个参数传入要删除几个元素（如果没有传入，表示删除后面所有元素） // 替换元素：第二个参数表示要替换几个元素：后面是用于替换的元素 // 插入元素：第二个参数，传入0，并后面跟上要插入的元素 this.letters.splice(); // 6.sort() 排序 this.letters.sort(); // 7.reverse() 反转 this.letters.reverse(); &#125; &#125; &#125;)&lt;/script&gt; VUE过滤器使用 filters 指令，html语法：{ { price | 过滤器} } 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;td&gt;&#123;&#123; item.price | showPrice &#125;&#125;&lt;/td&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; item: &#123; price: 25.00 &#125; &#125;, filters: &#123; showPrice(price) &#123; // 保留两位小数 return '￥' + price.toFixed(2) &#125; &#125; &#125;)&lt;/script&gt; 表单绑定 v-model表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。 Vue中使用v-model指令来实现表单元素和数据的双向绑定。 v-model原理v-model其实是一个语法糖，它的背后本质上是包含两个操作： v-bind绑定一个value属性 v-on指令给当前元素绑定input事件 &lt;input type=”text” v-model=”message”&gt; 等同于 &lt;input type=”text” v-bind:value=”message” v-on:input=”message = $event.target.value”&gt; v-model : radio123456789101112131415161718&lt;div id=\"app\"&gt; &lt;label for=\"male\"&gt; &lt;input type=\"radio\" id=\"male\" value=\"男\" v-model=\"sex\"&gt;男 &lt;/label&gt; &lt;label for=\"female\"&gt; &lt;input type=\"radio\" id=\"female\" value=\"女\" v-model=\"sex\"&gt;女 &lt;/label&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; sex: '' &#125; &#125;)&lt;/script&gt; v-model : checkbox复选框分为两种情况：单个勾选框和多个勾选框 单个勾选框： v-model即为布尔值。 此时input的value并不影响v-model的值。 多个复选框： 当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。 当选中某一个时，就会将input的value添加到数组中。 v-model : select和checkbox一样，select也分单选和多选两种情况。 单选：只能选中一个值。 v-model绑定的是一个值。 当我们选中option中的一个时，会将它对应的value赋值到mySelect中 多选：可以选中多个值。 v-model绑定的是一个数组。 当选中多个值时，就会将选中的option对应的value添加到数组mySelects中 修饰符lazy修饰符默认情况下，v-model默认是在input事件中同步输入框的数据的。 也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。 lazy修饰符可以让数据在失去焦点或者回车时才会更新： number修饰符：默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。 但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。 number修饰符可以让在输入框中输入的内容自动转成数字类型： trim修饰符：如果输入的内容首尾有很多空格，通常我们希望将其去除 trim修饰符可以过滤内容左右两边的空格","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"2-基础语法","slug":"2-基础语法","date":"2020-08-27T12:37:24.000Z","updated":"2020-09-05T05:44:00.444Z","comments":true,"path":"2020/08/27/2-基础语法/","link":"","permalink":"http://yoursite.com/2020/08/27/2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"基础语法插值操作Mustache语法（双大括号）在mustache语法中，不仅可以直接写变量，也可以写简单的表达式 123&lt;div&gt; &#123; &#123; message &#125; &#125;&lt;/div&gt;","text":"基础语法插值操作Mustache语法（双大括号）在mustache语法中，不仅可以直接写变量，也可以写简单的表达式 123&lt;div&gt; &#123; &#123; message &#125; &#125;&lt;/div&gt; v-once在某些情况下，可能不希望界面随意的跟随改变 12345&lt;div id=\"app\"&gt; &lt;h2 v-once&gt; &#123;&#123; message &#125;&#125; &lt;/h2&gt;&lt;/div&gt; 该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的) 该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变 v-html某些情况下，我们从服务器请求到的数据本身就是一个HTML代码 如果我们直接通过来输出，会将HTML代码也一起输出。 但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容。 如果我们希望解析出HTML展示，可以使用v-html指令 12345&lt;div id=\"app\"&gt; &lt;h2 v-html=“url&gt;&lt;!-- url: '&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;' --&gt; &lt;/h2&gt;&lt;/div&gt; 该指令后面往往会跟上一个string类型，会将string的html解析出来并且进行渲染 v-textv-text作用和Mustache比较相似：都是用于将数据显示在界面中 v-text通常情况下，接受一个string类型 1234&lt;div id=\"app\"&gt; &lt;h2 v-text=\"message\"&gt; &lt;/h2&gt;&lt;/div&gt; 一般不使用，因为不够灵活 v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法 1234&lt;div id=\"app\"&gt; &lt;h2 v-pre&gt; &#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!-- 将显示 &#123;&#123;message&#125;&#125; --&gt;&lt;/div&gt; v-cloak (cloak: 斗篷)在某些情况下，浏览器可能会直接显然出未编译的Mustache标签。 比如：延迟、循环过多导致等待、加载卡住 为了隐藏不美观的mustache，可以使用v-cloak 123&lt;div id=\"app\" v-cloak&gt; &lt;h2&gt; &#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt; 1234// 选择含有v-cloak属性的标签，并隐藏[v-cloak] &#123; display: none;&#125; 在VUE解析之前，div中有一个属性 v-cloak 在VUE解析之后，div中没有属性v-cloak 绑定属性v-bind除了内容需要动态决定外，某些属性也希望动态绑定（比如，a元素的href属性，img元素的src属性） 这个时候，可以使用v-bind指令： 作用：动态绑定属性 缩写：: 预期：any (with argument) | Object (without argument) 参数：attrOrProp(optional) 12345&lt;div id=\"app\"&gt; &lt;!-- 不可以在标签中使用mustache语法 --&gt; &lt;a v-bind:href=\"link\"&gt;&lt;/a&gt; &lt;img v-bind:src=\"link\"&gt;&lt;/div&gt; v-bind有一个对应的语法糖，也就是简写方式 1234&lt;div id=\"app\"&gt; &lt;a :href=\"link\"&gt;&lt;/a&gt; &lt;img :src=\"link\"&gt;&lt;/div&gt; v-bind动态绑定class很多时候，我们希望动态的来切换class，比如： 当数据为某个状态时，字体显示红色。 当数据另一个状态时，字体显示黑色。 绑定class有两种方式： 对象语法 数组语法 对象语法对象语法的含义是：class后面跟的是一个对象。 12345&lt;div id=\"app\"&gt; &lt;h2 v-bind:class=\"&#123;类名1: boolean, 类名2: boolean&#125;\"&gt; &#123;&#123; message &#125;&#125; &lt;/h2&gt;&lt;/div&gt; 用法一：直接通过{}绑定一个类 &lt;h2 :class=”{‘active’: isActive}”&gt;Hello World 用法二：也可以通过判断，传入多个值 &lt;h2 :class=”{‘active’: isActive, ‘line’: isLine}”&gt;Hello World 用法三：和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类 &lt;h2 class=”title” :class=”{‘active’: isActive, ‘line’: isLine}”&gt;Hello World 用法四：如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性 &lt;h2 class=”title” :class=”classes”&gt;Hello World 实例: 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;h2 v-bind:class=\"&#123;active: isActive, line: isLine&#125;\"&gt; &#123;&#123; message &#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '你好', isActive: true, isLine: true &#125; &#125;)&lt;/script&gt; 数组语法数组语法的含义是：class后面跟的是一个数组。 不常用 用法一：直接通过{}绑定一个类 &lt;h2 :class=”[‘active’]”&gt;Hello World 用法二：也可以传入多个值 &lt;h2 :class=“[‘active’, ‘line’]”&gt;Hello World 用法三：和普通的类同时存在，并不冲突注：会有title/active/line三个类 &lt;h2 class=”title” :class=“[‘active’, ‘line’]”&gt;Hello World 用法四：如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性 &lt;h2 class=”title” :class=”classes”&gt;Hello World v-bind绑定style可以利用 v-bind: style 来绑定一些CSS内联样式。 在写CSS属性名的时候，比如font-size 可以使用驼峰式 (camelCase) fontSize 或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’ 绑定style有两种方式： 对象语法 数组语法 对象语法:style=”{color: currentColor, fontSize: fontSize + ‘px’}” style后面跟的是一个对象类型 对象的key是CSS属性名称 对象的value是具体赋的值，值可以来自于data中的属性 value不加单引号则作为变量解析 数组语法12345678910&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt;&lt;script&gt; const app = new Vue(&#123; data: &#123; baseStyles: &#123;backgroundColor: 'red'&#125;, overridingStyle: &#123;fontSize: '40px'&#125; &#125; &#125;)&lt;/script&gt; style后面跟的是一个数组类型 多个值以” , “分割即可 计算属性——computed在某些情况，可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;h2&gt; &#123;&#123; fullname &#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; firstName: '张', lastName: '三' &#125;, // 计算属性 computed: &#123; fullName: function()&#123; return this.firstName+' '+this.lastName &#125; &#125; &#125;)&lt;/script&gt; 计算属性的setter和getter每个计算属性都包含一个getter和一个setter 在上面的例子中，只是使用getter来读取。 在某些情况下，也可以提供一个setter方法（不常用）。 计算属性一般没有set方法，是一个只读属性 1234567891011121314151617181920212223242526272829&lt;div id=\"app\"&gt; &lt;h2&gt; &#123;&#123; fullname &#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; firstName: '张', lastName: '三' &#125;, // 计算属性 computed: &#123; fullName: &#123; set: function(newValue) &#123; const names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125;, get: function() &#123; return this.firstName +' '+ lastName &#125; &#125; &#125; &#125;)&lt;/script&gt; 计算属性的缓存计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。 而methods属性每次调用都会执行一次。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"1-了解VUE","slug":"1-了解VUE","date":"2020-08-25T11:07:24.000Z","updated":"2020-09-05T05:43:13.333Z","comments":true,"path":"2020/08/25/1-了解VUE/","link":"","permalink":"http://yoursite.com/2020/08/25/1-%E4%BA%86%E8%A7%A3VUE/","excerpt":"了解VUE中文官方文档：https://cn.vuejs.org/v2/guide/ 认识Vue是一个渐进式框架，渐进式意味着可以将Vue作为应用的一部分嵌入其中，带来更丰富的交互体验；或者如果希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统，可以满足各种各样的需求","text":"了解VUE中文官方文档：https://cn.vuejs.org/v2/guide/ 认识Vue是一个渐进式框架，渐进式意味着可以将Vue作为应用的一部分嵌入其中，带来更丰富的交互体验；或者如果希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统，可以满足各种各样的需求 特点 解耦视图和数据 可复用的组件 前端路由技术 状态管理 虚拟DOM 安装 直接CDN引入 12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/\"&gt;&lt;/script&gt; 下载和引入 12345&lt;!-- 开发环境 --&gt;https://vue.js.org/js/vue.js&lt;!-- 生产环境 --&gt;https://vue.js.org/js/vue.min.js NPM安装 后续通过webpack和CLI的使用。 创建对象123456789101112131415&lt;div id=\"app\"&gt; &lt;h2&gt; hello &#123;&#123; name &#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; let app = new Vue(&#123; el: '#app', data: &#123; name: 'VueJS' &#125; &#125;)&lt;/script&gt; 创建Vue对象时，传入了一些options: { } { } 中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上 { } 中包含了data属性：该属性通常会存储一些数据 这些数据可以是我们直接定义的 也可以来自网络，从服务器加载 Vue列表的展示123456789101112131415&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in movies\"&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; movies: ['大话西游', '少年派', '星际穿越'] &#125; &#125;)&lt;/script&gt; VUE的MVVMModel-View-ViewModel，是一种软件架构模式。 View层： 视图层 在前端开发中，通常就是DOM层 主要作用是给用户展示各种信息 Model层： 数据层 数据可能是固定的死数据，更多的是来自服务器，从网络上请求的数据 VuwModel层： 视图模型层 视图模型层是View和Model沟通的桥梁 一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时反应到View中 另一方面，它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件（点击、滚动、touch等）时，可以监听到，并在需要的情况下改变对应的Data VUE的options选项官方文档：https://cn.vuejs.org/v2/api/ el ： 类型：string | HTMLElement 作用：决定之后VUE实例会管理哪一个DOM data ： 类型：Object | Function (组件中data必须是一个函数) 作用：VUE实例对应的数据对象 methods ： 类型：{ [key: string] : Function } 作用：定义属于VUE的一些方法，可以在其他地方调用，也可以在指令中使用 VUE的生命周期vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件创建、数据初始化、挂载、更新、销毁，这就是一个组件所谓的生命周期。 beforeCreate 实例组件刚创建，元素DOM和数据都还没有初始化，暂时不知道能在这个周期里面进行生命操作。 created 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。有人问了，请求都是异步的，并不会阻碍实例加载。这是我个人水平的问题，这边改正，在这个周期里面，请求因为是异步的，不会阻碍实例加载，除非是那些同步操走才会导致页面空白。这样说来，在这个周期里面进行请求，渲染速度反而会更快。 beforeMount DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示，这是因为Vue采用了Virtual DOM（虚拟Dom）技术。先占住了一个坑。 mounted 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。可以在这边请求，不过created请求会更好一些。这个周期适合执行初始化需要操作DOM的方法。 beforeUpdate 只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。 updated 只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。 beforeDestroy 这个周期是在组件销毁之前执行，在我项目开发中，觉得这个其实有点类似路由钩子beforeRouterLeave,都是在路由离开的时候执行，只不过beforeDestroy无法阻止路由跳转，但是可以做一些路由离开的时候操作，因为这个周期里面还可以使用data和method。比如一个倒计时组件，如果在路由跳转的时候没有清除，这个定时器还是在的，这时候就可以在这个里面清除计时器。 Destroyed 说实在的，我还真的不知道这个周期跟beforeDestroy有什么区别，我在这个周期里面调用data的数据和methods的方法都能调用，所以我会觉得跟beforeDestroy是一样的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"8-Express框架","slug":"8-Express框架","date":"2020-08-24T09:12:21.000Z","updated":"2020-08-25T12:21:44.564Z","comments":true,"path":"2020/08/24/8-Express框架/","link":"","permalink":"http://yoursite.com/2020/08/24/8-Express%E6%A1%86%E6%9E%B6/","excerpt":"Express框架Express框架是什么Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助创建各种web应用 可以使用 npm install express 命令进行下载","text":"Express框架Express框架是什么Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助创建各种web应用 可以使用 npm install express 命令进行下载 Express框架特性 提供了方便简介的路由定义方式 对获取HTTP请求参数进行了简化处理 对模板引擎支持程度高，方便渲染动态HTML页面 提供了中间件机制有效控制HTTP请求 拥有大量第三方中间件对功能进行扩展 中间件什么是中间件中间件就是一堆方法，可以接收客户端发来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理 中间件主要由两部分组成，中间件方法以及请求处理函数 中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求 可以针对同一个请求设置多个中间件，对同一个请求进行多次处理 默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配 可以调用next方法，将请求的控制权交给下一个中间件，知道遇到结束请求的中间件 123456789// 传递next参数app.get('/request', (req, res, next) =&gt; &#123; req.name = \"张三\"; // 调用next方法 next();&#125;);qpp.get('/request', (req, res) =&gt; &#123; res.send(req.name);&#125;); app.use中间件用法app.use匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求 1234app.use((req, res, next) =&gt; &#123; console.log(req.url); next();&#125;); app.use第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收请求 1234app.use('/admin', (req, res, next) =&gt; &#123; console.log(req.url); next();&#125;); 中间件应用 路由保护，客户端在访问需要登陆的页面时，可以先使用中间件判断用户登陆状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登陆的页面 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中 自定义404页面 123app.use((req, res, next) =&gt; &#123; res.status(404).send('页面不存在');&#125;) 错误处理中间件在程序执行的过程中，不可避免会出现一些无法预料的错误，比如文件读取失败，数据库连接失败，错误处理中间件是一个集中处理错误的地方 123app.use((err, req, res, next) =&gt; &#123; res.status(500).send('服务器发送未知错误');&#125;) 当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件 1234567app.get('/', (req, res, next) =&gt; &#123; fs.readFile(\"/file-does-not-exist\", (err, data) =&gt;&#123; if(err) &#123; next(err); &#125; &#125;)&#125;) 捕获错误在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发送错误可以通过catch方法捕获 try catch可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能捕获其他类型的API发生的错误 1234567app.get(\"/\", async (req, res, next) =&gt; &#123; try &#123; await User.find(&#123;name: '张三'&#125;) &#125; catch(ex) &#123; next(ex); &#125;&#125;); Express请求处理构建模块化路由基本功能： 12345678910const express = require('express');// 创建路由对象const home = express.Router();// 将路由和请求路径进行匹配app.use('/home', home);// 在home路由下继续创建路由home.get('/index', () =&gt; &#123; // /home/index res.send('欢迎');&#125;) 模块化： 123456// home.jsconst home = express.Router();home.get('/index', () =&gt; &#123; res.send('欢迎来到展示首页');&#125;);moudule.exports = home; 123456// admin.jsconst admin = express.Router();admin.get('/index', () =&gt; &#123; res.send('欢迎来到管理首页');&#125;);moudule.exports = admin; 12345// app.jsconst home =require('./route/home.js');const admin = require('./route/admin.js');app.use('/home', home);app.use('/admin', admin); GET参数的获取Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回 1234// 接收地址栏中问号后面的参数app.get('/', (req, res) =&gt; &#123; console.log(req.query);&#125;) POST参数的获取Express中接收post请求参数需要第三方包 body-parser 1234567891011// 引入body-parser模块const bodyParser = require('body-parser');// 配置body-parser模块// extended: false 方法内部使用querystring模块处理请求参数格式// extended: true 方法内部使用第三方模块qs处理请求参数格式app.use(bodyParser.urlencoded(&#123; extended: false &#125;));// 接收请求app.post('/add', (req, res) =&gt; &#123; //接收请求参数 console.log(req.body);&#125;) Express路由参数1localhost:3000&#x2F;find&#x2F;123 1234// :id是占位符，表示当前路由需要接收一个id作为参数app.get('/find/:id', (req, res) =&gt; &#123; console.log(req.params); // &#123;id: 123&#125;&#125;); 静态资源的处理通过Express内置的express.static可以方便地托管静态文件，例如：img、CSS、JavaScript文件 1app.use(express.static('public')); 模板引擎 为了使art-template模板引擎能更好地和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了express-art-template 使用 npm install art-template express-art-template 命令进行安装 1234567891011// 当渲染后缀为art的模板时，使用express-art-templateapp.engine('art', require('express-art-template'));// 设置模板存放目录app.set('views', path.join(__dirname. 'views'));// 渲染模板时不写后缀，默认拼接art后缀app.set('view engine', 'art');app.get('/', (req, res) =&gt; &#123; // 渲染模板 res.render('index')''&#125;); app.locals对象将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到 1234567app.locals.users = [&#123; name: '张三', age: 20&#125;, &#123; name: '李四', age: 30&#125;]","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"7-模板引擎artTemplate","slug":"7-模板引擎artTemplate","date":"2020-08-24T06:52:21.000Z","updated":"2020-08-24T09:07:37.910Z","comments":true,"path":"2020/08/24/7-模板引擎artTemplate/","link":"","permalink":"http://yoursite.com/2020/08/24/7-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EartTemplate/","excerpt":"模板引擎artTemplate模板引擎模板引擎是第三方模块 让开发者以更加友好的方式拼接字符串，使项目代码更加清晰，易于维护","text":"模板引擎artTemplate模板引擎模板引擎是第三方模块 让开发者以更加友好的方式拼接字符串，使项目代码更加清晰，易于维护 art-template模板引擎 在命令行工具使用 npm install art-template 命令下载 使用 const template = require(‘art-template’) 引入模板引擎 告诉模板引擎要拼接的数据和模板在哪 const html = template(‘模板路径’, 数据); 使用模板语法告诉模板引擎， 模板与数据应该如何拼接 模板路径是绝对路径 art-template代码示例123456789// 导入模板引擎模块const template = require('art-template');// 将特定模块与特定数据进行拼接const html = template('./index.art', &#123; data: &#123; name: '张三', age: 20 &#125;&#125;); 1234&lt;div&gt; &lt;span&gt;&#123;&#123;data.name&#125;&#125;&lt;&#x2F;span&gt; &lt;span&gt;&#123;&#123;data.age&#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 模板语法 art-template同时支持两种模板语法：标准语法和原始语法 标准语法可以让模板更容易读写，原始语法具有强大的逻辑处理能力 标准语法：{ { 数据 } } 原始语法：&lt;%=数据 %&gt; 输出将某项数据输出在模板中，标准语法和原始语法如下： 标准语法：{ { 数据 } } 原始语法：&lt;%=数据 %&gt; 123456789&lt;!-- 标准语法 --&gt;&lt;h2&gt;&#123; &#123; value &#125; &#125;&lt;&#x2F;h2&gt;&lt;h2&gt;&#123; &#123; a ? b : c &#125; &#125;&lt;&#x2F;h2&gt;&lt;h2&gt;&#123; &#123; a + b &#125; &#125;&lt;&#x2F;h2&gt;&lt;!-- 原始语法 --&gt;&lt;h2&gt; &lt;%&#x3D; value %&gt; &lt;&#x2F;h2&gt;&lt;h2&gt; &lt;%&#x3D; a ? b : c %&gt; &lt;&#x2F;h2&gt;&lt;h2&gt; &lt;%&#x3D; a + b %&gt; &lt;&#x2F;h2&gt; 原文输出如果数据中携带HTML标签，默认模板引擎不会解析标签，会将其转义后输出 标准语法：{ {@ 数据} } 原始语法： &lt;%- 数据%&gt; 条件判断在模板中可以根据条件决定显示哪块HTML代码 123456789101112&lt;!-- 标准语法 --&gt;&#123; &#123; if 条件 &#125; &#125; . . . &#123; &#123; &#x2F;if &#125; &#125;&#123; &#123; if v1 &#125; &#125; . . . &#123; &#123; else if v2 &#125; &#125; . . . &#123; &#123; &#x2F;if &#125; &#125;&lt;!-- 原始语法 --&gt;&lt;% if (value) &#123; %&gt; . . . &lt;% &#125; %&gt; &lt;% if (v1) &#123; %&gt; . . . &lt;% &#125; else if (v2) &#123; %&gt; . . . &lt;% &#125; %&gt; 循环 标准语法：{ { each 数据 } } { { /each } } 原始语法：&lt;% for( ) { %&gt; &lt;% } %&gt; 123456789&lt;!-- 标准语法 --&gt;&#123; &#123; each target &#125; &#125; &#123; &#123; $index &#125; &#125; &#123; &#123; $value &#125; &#125;&#123; &#123; &#x2F;each &#125; &#125;&lt;!-- 原始语法 --&gt;&lt;% for(var i&#x3D;0; i &lt; target.length; i++) &#123; %&gt; &lt;%&#x3D; i %&gt; &lt;%&#x3D; target[i] %&gt;&lt;% &#125; %&gt; 子模版使用子模版可以将网站公共区块（头部、尾部）抽离到单独的文件中 标准语法：{ { include ‘模板’ } } 原始语法：&lt;% include(‘模板’) %&gt; 12345&lt;!-- 标准语法 --&gt;&#123; &#123; include &#39;.&#x2F;header.art&#39; &#125; &#125;&lt;!-- 原始语法 --&gt;&lt;% include(&#39;.&#x2F;header.art&#39;) %&gt; 模板继承使用模板继承可以将网站HTML骨架抽离到单独的文件中，其他页面模板可以继承骨架文件 12345678910111213&#x2F;&#x2F; HTML骨架模板&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;HTML骨架模板&lt;&#x2F;title&gt; &#x2F;&#x2F; 预留位置已填充特定信息 &#123; &#123; block &#39;head&#39; &#125; &#125; &#123; &#123; &#x2F;block &#125; &#125; &lt;&#x2F;head&gt; &lt;body&gt; &#123; &#123; block &#39;content&#39; &#125; &#125;&#123; &#123; &#x2F;block&#125; &#125; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 123456789&#x2F;&#x2F; 继承模板&#123; &#123; extend &#39;.&#x2F;layout.art&#39; &#125; &#125;&#x2F;&#x2F; 填充内容&#123; &#123; block &#39;head&#39; &#125; &#125;&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;.&#x2F;main.css&quot;&gt;&#123; &#123; &#x2F;block &#125; &#125;&#123; &#123; block &#39;content&#39; &#125; &#125;&lt;p&gt;&#123; &#123; msg &#125; &#125;&lt;&#x2F;p&gt;&#123; &#123; &#x2F;block &#125; &#125; 模板配置 向模板中导入变量 template.defaults.imports.变量名 = 变量值 设置模板根目录 template.defaults.root = 模板目录 设置模板默认后缀 template.defaults.extname = ‘.art’","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"6-数据库","slug":"6-数据库","date":"2020-08-23T03:22:23.000Z","updated":"2020-08-24T06:53:41.746Z","comments":true,"path":"2020/08/23/6-数据库/","link":"","permalink":"http://yoursite.com/2020/08/23/6-%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"数据库数据库概述以及环境搭建为什么使用数据库 动态网站中的数据都是存储在数据库中的 数据库可以用来持久存储客户端通过表单收集的用户信息 数据库软件本身可以对数据进行高效的管理","text":"数据库数据库概述以及环境搭建为什么使用数据库 动态网站中的数据都是存储在数据库中的 数据库可以用来持久存储客户端通过表单收集的用户信息 数据库软件本身可以对数据进行高效的管理 什么是数据库数据库即存储数据的仓库，可以将数据进行有序的分门别类的存储，它是独立与语言之外的软件，可以通过API操作它 常见的数据库软件有：mysql、mongoDB、oracle MongoDB数据库下载安装下载地址：https://www.mongodb.com/download-center/community 数据库相关概念在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据） 术语 解释说明 database 数据库，nongoDB数据库软件中可以建立多个数据库 collection 集合，一组数据的集合，可以理解为JavaScript中的数组 document 文档，一条具体的数据，可以理解为JavaScript中的对象 field 字段，文档中的属性名称，可以理解为JavaScript中的对象属性 Mongoose第三方包 使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose 使用npm install mongoose命令下载 数据库连接使用mongoose提供的connect方法即可连接数据库 123mongoose.connect('mongodb://localhost:playground') .then(() =&gt; console.log('数据库连接成功')) .catch(err =&gt; console.log('数据库连接失败', err)); 创建数据库在MongoDB中不需要显式创建数据库，如果正在使用的数据库不存在，MongoDB会自动创建 MongoDB增删改查操作创建集合创建集合分两步，一是对集合设定规则，二是创建集合，创建mongoose.Schema构造函数的实例即可创建集合 123456789101112// 设定集合规则const courseSchema = new mongoose.Schema(&#123; name: String, author: String, isPublished: Boolean&#125;);// 创建集合并应用规则// model方法创建集合// 第一个参数为集合的名称，此处为Course，实际在数据库中为courses// 第二个参数为应用的集合规则// 返回的是集合的构造函数coust Course = mongoose.model('Course', courseSchema); 创建文档创建文档实际上就是向集合中插入数据 创建集合实例 调用实例对象下的save方法将数据保存到数据库中 直接创建123456789// 创建集合实例const course = new Course(&#123; name: 'Node.js course', author: 'heima', tags: ['node', 'backend'], isPublished: true&#125;);// 将数据保存到数据库中course.save(); 通过集合构造函数的create方法创建123456789101112// 第一个参数是集合实例// 第二个参数为回调函数，其中第一个参数为错误对象，第二个为插入到文档Course.create(&#123; name: 'Node.js', author: 'heima', isPublished: true&#125;, (err, doc) =&gt; &#123; // 错误对象 console.log(err); // 当前插入的文档 console.log(doc);&#125;) 1234567891011Course.create(&#123; name: 'Node.js', author: 'heima', isPublished: true&#125;) .then(result =&gt; &#123; console.log(result);&#125;) .catch(err =&gt; &#123; console.log(err);&#125;) mongoDB数据库导入数据mongoimport -d 数据库名称 -c 集合名词 –file 要导入的数据文件 –file前有两个- 导入到数据文件带路径 找到mongodb数据库的安装目录，将安装目录下的bin目录放置在环境变量中才能使用 查询文档完全匹配查询 find( ) 12// 构造函数的find方法根据条件查找文档，条件为空则查找所有文档Course.find().then(result =&gt; console.log(result)) 1234567891011// 返回的是文档集合// 无论多少，返回的都是数组集合[&#123; _id: ****************, name: '***', author: '****'&#125;, &#123; _id: ****************, name: '***', author: '****'&#125;] findOne( ) 123// 构造函数的findOne方法根据条件查找文档// 仅返回一个对象，默认返回当前集合的第一条文档Course.findOne(&#123;name: 'node.js'&#125;).then(result =&gt; console.log(result)); 范围匹配查询12// 匹配大于、小于User.find(&#123;age: &#123;$gt: 20, $lt: 50&#125;&#125;).then(result =&gt; console.log(result)); $gt：大于 $lt：小于 12// 匹配包含User.find(&#123;hobbies: &#123;$in: '游泳'&#125;&#125;).then(result =&gt; console.log(result)); $in：包含 123// 选择要查询的字段// 查询name、email字段，并且不含_idUser.find().select('name email -_id').then(result =&gt; console.log(result)); 12345// 将数据按顺序排序// 根据年龄字段升序排列User.find().sort('age').then(result =&gt; console.log(result));// 根据年龄字段降序排列User.find().sort('-age').then(result =&gt; console.log(result)); 12// skip跳过多少条数据，limit限制查询数量User.find().skip(2).limit(2).then(result =&gt; console.log(result)); 删除文档1234// 删除单个// 返回被删除的字段 // 当查询匹配到多个文档，则删除第一个Course.findOneAndDelete(&#123;&#125;).then(result =&gt; console.log(result)); 1234// 删除多个// 返回一个对象，n表示删除的个数，ok为1表示操作成功// 当匹配到多个文档，**全部删除**User.deleteMany(&#123;&#125;).then.(result =&gt; console.log(result)); 更新文档12// 更新单个User.updatOne(&#123;查询条件&#125;, &#123;要修改的值&#125;).then(result =&gt; console.log(result)); 12// 更新多个User.updateMany(&#123;查询条件&#125;, &#123;要修改的值&#125;).then(result =&gt; console.log(result)); mongoose验证在创建集合规则时，可以设置当前字段的验证规则，验证失败则输出插入失败 require: true 必传字段 minlength: Number 最小长度 manlength: Number 最大长度 trim: true 去除字符串两边的空格 min: 2 数值最小为2 max: 100 数值最大为100 default: Object 定义默认值，让不输入时自动存入默认值 enum: [‘html’, ‘css’, ‘后端’] 定义传入值的限制，只能上传特定的值 自定义验证器： validate: { ​ 函数类型，参数v为传入的值 ​ validator: v =&gt; { ​ 自定义的判断规则，返回布尔值 ​ } ​ 自定义错误信息 ​ message: ‘传入的值不符合要求’ } required: [true, ‘未传入标题’] 可通过数组定义规则 第一个布尔值表示必传，第二个为错误信息 12345678910111213141516171819new mongoose.Schema(&#123; title: &#123; type: String, // 值的类型 required: true, // 是否为必传字段 // required: [true, '未传入标题']，可通过数组定义规则， 第一个布尔值表示必传，第二个未错误信息 minlength: 2, // 最小长度 maxlength: 10, // 最大长度 &#125;, author: &#123; type: String, validate: &#123; validator: v =&gt; &#123; return v &amp;&amp; v.length&gt;4 &#125;, message: '传入的值不合要求', &#125; &#125;&#125;) 获取错误信息1234567891011User.create(&#123;title: 'aa', age: 60&#125;); .then(result =&gt; console.log(result)); .catch(error =&gt; &#123; // 获取错误信息中的errors对象 const err = error.errors; for (var attr in err) &#123; // 循环输出对象中每个对象的message的值，表示错误的具体信息 console.log(err[attr]['message']); &#125; &#125;) 集合关联通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同的集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联 使用id对集合进行关联 使用populate方法进行关联集合查询 12345678910111213141516// 用户集合const User = mongoose.model('User', new mongoose.Schema(&#123; name: &#123; type: String, &#125;;&#125;))// 文章集合const Post = mongoose.model('Post', new mongoose.Schema(&#123; title: &#123; type: String &#125;, // 使用ID将文章集合和作者集合进行关联 author: &#123; type: mongoose.Schema.Type.ObjectId, ref: 'User'&#125;&#125;))// 联合查询post.find(); .populate('author'); .then((err, result) =&gt; console.log(result));","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"5-Node.js异步编程","slug":"5-Node.js异步编程","date":"2020-08-22T05:02:24.000Z","updated":"2020-08-23T03:41:43.328Z","comments":true,"path":"2020/08/22/5-Node.js异步编程/","link":"","permalink":"http://yoursite.com/2020/08/22/5-Node.js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","excerpt":"Node.js异步编程同步API、异步API同步API：只有当前API执行完成后，才能继续执行下一个API 异步API：当前API的执行不会阻塞后续代码的执行","text":"Node.js异步编程同步API、异步API同步API：只有当前API执行完成后，才能继续执行下一个API 异步API：当前API的执行不会阻塞后续代码的执行 同步API、异步API的区别（获取返回值）同步API可以从返回值中拿到API执行的结果，但是异步API是不可以的 回调函数自己定义函数让别人去调用 1234567891011function getMsg(callback) &#123; setTimeout(function()&#123; callback(&#123; msg: 'hello' &#125;) &#125;, 2000)&#125;getMsg(function(data)&#123; console.log(data);&#125;); 同步API、异步API的区别（代码执行顺序）同步API从上到下依次执行，前面代码会阻塞后面代码的执行 异步API不会等待API执行完成后再向下执行 12345678console.log('start');setTimeout(() =&gt; &#123; console.log('2秒之后执行的代码')&#125;, 2000);setTimeout(() =&gt; &#123; console.log('0秒执行的代码')&#125;, 0);console.log('end'); Node.js中的异步API123456789101112// 异步编程回调地狱const fs = require('fs');fs.readFile('./1.txt', 'utf8', (err, result1) =&gt; &#123; console.log(result1); fs.readFile('./2.txt', 'utf8', (err,result2)=&gt;&#123; console.log(result2); fs.readFile('./3.txt', 'utf8', (err,result3)=&gt;&#123; console.log(result3); &#125;) &#125;)&#125;) PromisePromise出现的目的解决Node.js异步编程中回调地狱的问题 1234567891011121314151617181920let Promise = new Promise((resolve, reject) =&gt; &#123; fs.readFile('./1.txt', 'utf8', (err,result) =&gt; &#123; if(err != null) &#123; reject(err); &#125; else &#123; resolve(result); &#125; &#125;);&#125;);// 当异步API调用成功，向then方法中传递resolve的参数并调用匿名函数promise.then((result) =&gt; &#123; console.log(result);&#125;)// 当异步API调用失败，向catch方法中传递reject的参数并调用匿名函数promise.catch((err) =&gt; &#123; console.log(err);&#125;) 用Promise解决调用地狱12345678910111213141516171819202122232425262728293031const fs = require('fs');// 为了保证函数的执行顺序，将Promise放在一个函数中建立// 在调用这个函数时，才会执行Promisefunction p1 () &#123; return new Promise ((resolve, reject) =&gt; &#123; fs.readFile('./1.txt', 'utf8', (err, result) =&gt; &#123; resolve(result); &#125;) &#125;);&#125;function p2 () &#123; return new Promise ((resolve, reject) =&gt; &#123; fs.readFile('./2.txt', 'utf8', (err, result) =&gt; &#123; resolve(result); &#125;) &#125;);&#125;function p3 () &#123; return new Promise ((resolve, reject) =&gt; &#123; fs.readFile('./3.txt', 'utf8', (err, result) =&gt; &#123; resolve(result); &#125;) &#125;);&#125;p1().then((r1) =&gt; &#123; console.log(r1);&#125;) 异步函数异步函数是异步编程语法的终极解决方案，它可以将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了 1const fn = async() =&gt; &#123; &#125;; 1async function fn () &#123; &#125; 在普通函数定义的前面加上async关键字，普通函数就变成了异步函数 异步函数默认的返回值是promise对象 在异步函数内部使用throw关键字进行错误的抛出 12345678910111213141516async function fn () &#123; // 使用throw关键字在调用失败时抛出错误 throw '发生了错误'; // 使用return返回调用成功时的返回值 return 123;&#125;// 当调用成功时调用then方法并接收return的返回值作为参数fn().then(function(data) &#123; console.log(data);&#125;)// 当调用失败时调用catch方法并接收throw的返回值作为参数fn().catch(function(err) &#123; console.log(err);&#125;) await关键字： 它只能出现在异步函数中 await promise await后面只能写promise对象，写其他类型的API是不可以的 await关键字可以暂停异步函数向下执行，直到promise返回结果 可以利用util模块中的promisify的方法，使异步API返回promise对象 1234567891011121314151617181920async function p1() &#123; return 'p1';&#125;async function p2() &#123; return 'p2';&#125;async function p3() &#123; return 'p3';&#125;async function run() &#123; let r1 = await p1() let r1 = await p2() let r1 = await p3() console.log(r1) console.log(r2) console.log(r3)&#125;run(); 12345678910111213141516const fs = require('fs');// 引入util模块中的promisify方法const promisify = require('util').promisify;// 对fs.readFile进行包装，令其返回promise对象const readFile = promisify(fs.readFile);async function run() &#123; let r1 = await readFile('./1.txt', 'utf8') let r2 = await readFile('./2.txt', 'utf8') let r3 = await readFile('./3.txt', 'utf8') console.log(r1) console.log(r2) console.log(r3)&#125;run();","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"4-请求响应原理以及HTTP协议","slug":"4-请求响应原理以及HTTP协议","date":"2020-08-21T11:20:44.000Z","updated":"2020-08-22T14:20:36.365Z","comments":true,"path":"2020/08/21/4-请求响应原理以及HTTP协议/","link":"","permalink":"http://yoursite.com/2020/08/21/4-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AHTTP%E5%8D%8F%E8%AE%AE/","excerpt":"请求响应原理以及HTTP协议创建web服务器123456789101112// 引用创建网站服务器的系统模块const http = require('http');// 创建网站服务器对象const app = http.createServer();// 当客户端发送请求的时候app.on('request', (req, res) =&gt; &#123; // 响应 res.end('&lt;h1&gt;hi, user&lt;/h1&gt;');&#125;);// 监听3000端口app.listen(3000);console.log('服务器已启动，监听3000端口，请访问localhost:3000')","text":"请求响应原理以及HTTP协议创建web服务器123456789101112// 引用创建网站服务器的系统模块const http = require('http');// 创建网站服务器对象const app = http.createServer();// 当客户端发送请求的时候app.on('request', (req, res) =&gt; &#123; // 响应 res.end('&lt;h1&gt;hi, user&lt;/h1&gt;');&#125;);// 监听3000端口app.listen(3000);console.log('服务器已启动，监听3000端口，请访问localhost:3000') HTTP协议HTTP协议的概念超文本传输协议（HyperText Transfer Protocol），规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准 报文在HTTP请求和响应的过程中传递的数据块叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式 请求报文 请求方式（Requrst Method） GET 请求数据 POST 发送数据 请求地址（Request URL） 12345app.on('request', (req, res) =&gt; &#123; req.headers // 获取请求报文 req.url // 获取请求地址 req.method // 获取请求方法&#125;) 响应报文带有HTTP状态码以及内容类型 内容类型默认为 text/plain，且不会以utf-8编码，中文会乱码 HTTP状态码 200：请求成功 404：请求的资源没有被找到 500：服务器端错误 400：客户端请求有语法错误 内容类型 text/html text/css application/javascript image/jpeg application/json 1234res.writeHead(200, &#123; // 返回html文件内容类型，并以utf-8编码，否则中文会乱码 'content-type': 'text/html; charset=UTF8'&#125;) text/html和text/plain的区别 text/html的意思是将文件的content-type设置为text/html的形式，浏览器在获取到这种文件时会自动调用html的解析器对文件进行相应的处理。 text/plain的意思是将文件设置为纯文本的形式，浏览器在获取到这种文件时并不会对其进行处理。 HTTP请求与响应处理请求参数客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端 GET请求参数 参数被放置在浏览器地址栏中，例如：http://localhost:3000/?name=zhangsan&amp;age=20 12345678910111213141516// 引入内置模块url解析url地址const url = require('url');// 解析请求的url地址并返回一个对象url.parse(req.url);// url.parse(url, true||false);// 第一个参数为要解析的url地址// 第二个参数为将查询参数解析成对象形式console.log(url.parse(req.url, true))// 最终需要获取的是url.parse返回的query对象和pathname路径let &#123; query, pathname &#125; = url.parse(req.url, true);console.log(query.name);console.log(query.age);console.log(pathname); POST请求参数 参数被放置在请求体中进行传输 获取POST参数需要使用data事件和end事件 使用querystring系统模块将参数转换成对象格式 12345678910111213// 导入系统模块querystring用于将HTTP参数转换为对象格式const querystring = require('querystring');app.on('request', (req, res) =&gt; &#123; let postData = ''; // 监听参数传输事件 req.on('data', (keys) =&gt; postData += keys;); // 监听参数传输完毕事件 req.on('end', () =&gt; &#123; // 将字符串参数转换成对象形式 console.log(querystring.parse(postData)); &#125;);&#125;); 路由路由是指客户端请求地址与服务器端程序代码的对应关系，简单说就是，请求什么响应什么 1234567891011121314151617181920212223// 当客户端发来请求的时候app.on('request', (req, res) =&gt; &#123; // 获取请求方式并转换成小写 const method = req.method.toLowerCase(); // 获取客户端的请求路径 let &#123; pathname &#125; = url.parse(req.url); // 响应报文处理，否则中文显示为乱码 res.writeHead(200, &#123; 'content-type': 'text/html; charset=utf8' &#125;); if (method == 'get') &#123; if (pathname == '/' || pathname == '/index') &#123; res.end('欢迎来到首页'); &#125; else if (pathname == '/list') &#123; res.end('欢迎来到列表页'); &#125; else &#123; res.end('访问页面不存在'); &#125; &#125; else if (method == 'post') &#123; &#125;&#125;); 静态资源服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件 动态资源相同的请求地址不同的相应资源，这种资源就是动态资源 静态资源访问读取路径12345678910111213141516171819202122232425262728293031323334353637383940414243const http = require('http');const url = require('url');const path = require('path');const fs = require('fs');const mime = require('mime');// 创建web服务器端const app = http.createServer();app.on('request', (req, res) =&gt; &#123; // 获取用户的请求路径 let pathname = url.parse(req.url.pathname); // 当不输入页面时想访问首页内容 pathname = pathname == '/' ? '/index.html' : pathname; // 将用户的请求路径转换为实际的服务器硬盘路径 // 使用path模块提供的join方法拼接路径 // __dirname 代表当前文件所在的绝对路径 let realPath(path.join(__dirname, 'public' + pathname)); // 获取目标文件的所有类型 let type = mime.getType(realPath); // 按照路径读取文件 // 使用fs模块的readFile方法 // 第一个参数为文件的路径 // 第二个参数为回调函数 // 回调函数中有两个参数，一个是error，当文件读取成功时为空，失败时返回一个错误对象；另一个是result，当文件读取成功时返回文件内容，失败时为空 fs.readFile(realPath, (error, result) =&gt; &#123; // 如果文件读取失败 if (error != null) &#123; res.writeHead(404, &#123; 'content-type': 'text/html; charset=utf8' &#125;) res.end('文件读取失败'); return; &#125; // 成功读取则输出文件内容 res.writeHead(200, &#123; // 指定返回资源的类型 'content-type': type &#125;) res.end(result); &#125;)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"3-服务器端基础概念","slug":"3-服务器端基础概念","date":"2020-08-20T13:56:44.000Z","updated":"2020-08-21T12:51:41.913Z","comments":true,"path":"2020/08/20/3-服务器端基础概念/","link":"","permalink":"http://yoursite.com/2020/08/20/3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"服务器端基础网站的组成网站应用程序主要分为两大部分：客户端和服务器端 客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建 服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑","text":"服务器端基础网站的组成网站应用程序主要分为两大部分：客户端和服务器端 客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建 服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑 Node网站服务器能够提供网站访问服务的机器就是网站服务器，能够接收客户端的请求，能够对请求做出响应 IP地址互联网中设备的唯一标识 IP是Internet Protocol Address的简写，代表互联网协议地址 域名由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址 http://www.ithema.com =&gt; http://124.165.219.100/ 虽然在地址栏中输入的是网址，但是最终还是会将域名转换为ip才能访问到指定的网站服务器 端口端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同服务 URL统一资源定位符（Uniform Resource Locator），是专为标识Internet网上资源位置而设的一种编址方式 URL的组成传输协议：//服务器IP或域名：端口/资源所在位置标识 http://www.baodu.com/news/2018018/0814.html http：超文本传输协议，提供了一种发布和接收HTML页面的方法 开发过程中客户端和服务器端说明在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"2-package.json文件","slug":"2-package.json文件","date":"2020-08-20T12:56:44.000Z","updated":"2020-08-20T15:24:14.126Z","comments":true,"path":"2020/08/20/2-package.json文件/","link":"","permalink":"http://yoursite.com/2020/08/20/2-package.json%E6%96%87%E4%BB%B6/","excerpt":"package.json文件node_modules文件夹的问题 文件夹以及内容过多过碎，当我们将项目整体拷贝给别人时，传输速度会很慢 复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错","text":"package.json文件node_modules文件夹的问题 文件夹以及内容过多过碎，当我们将项目整体拷贝给别人时，传输速度会很慢 复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错 package.json文件的作用项目描述文件，记录当前项目信息，例如项目名称、版本、作者、GitHub地址、当前项目依赖了哪些第三方模块等 使用npm init -y命令生成 当传输项目时，可以不传输node_modules文件夹而在命令行中使用 1npm install 即可根据package.json文件自动下载依赖的模块 项目依赖 在项目开发阶段和线上运营阶段，都需要依赖第三方包，称为项目依赖 使用 npm install 包名 命令下载的文件都会默认被添加到package.json文件的dependencies字段中 开发依赖 在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖 使用 npm install 包名 –save-dev 命令将包添加到package.json文件的devDependencies字段中 12345&#123; \"devDependencies\": &#123; \"gulp\": \"^3.9.1\" &#125;&#125; package-lock.json文件的作用 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作 Node.js中模块的加载机制模块查找规则——当模块拥有路径但没有后缀时12require('./find.js');require('./find'); require方法根据模块路径查找模块，如果是完整路径，直接引入模块 如果模块后缀省略，先找同名JS文件，再找同名JS文件夹 如果找到了同名文件夹，找文件夹中的index.js 如果文件夹中没有index.js文件，就会去当前文件夹中的package.js文件中查找main选项中的入口文件 如果找指定的入口文件不存在或者没有指定入口文件，就会报错，模块没被找到 模块查找规则——当模块没有路径且没有后缀时1require('find'); Node.js会假设它是系统模块 Node.js会去node_modules文件夹中 首先看是否有该名字的JS文件 再看是否有该名字的文件夹 如果是文件夹，看里面是否有index.js 如果没有index.js，查看该文件夹中的package.json中的main选项确定模块入口文件 否则找不到报错","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"2-ES6基础知识2","slug":"2-ES6基础知识2","date":"2020-08-05T06:27:12.000Z","updated":"2020-08-05T12:39:32.309Z","comments":true,"path":"2020/08/05/2-ES6基础知识2/","link":"","permalink":"http://yoursite.com/2020/08/05/2-ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/","excerpt":"","text":"ES6基础知识Set和Map数据结构","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"1-ES6基础知识1","slug":"1-ES6基础知识1","date":"2020-08-04T11:43:14.000Z","updated":"2020-08-05T12:38:17.903Z","comments":true,"path":"2020/08/04/1-ES6基础知识1/","link":"","permalink":"http://yoursite.com/2020/08/04/1-ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/","excerpt":"ES6基础知识ECMAScript 6.0（简称ES6）是JavaScript语言的下一代标准，提供了大量的新特性，简化了JavaScript语言的写法，而且扩大了应用范围。 基础知识中介绍包含： 声明变量和常量新关键字 模板字符串 箭头函数 解构赋值 Set和Map数据结构","text":"ES6基础知识ECMAScript 6.0（简称ES6）是JavaScript语言的下一代标准，提供了大量的新特性，简化了JavaScript语言的写法，而且扩大了应用范围。 基础知识中介绍包含： 声明变量和常量新关键字 模板字符串 箭头函数 解构赋值 Set和Map数据结构 声明变量let和constlet命令ES6中新增的let关键字，声明的变量只在代码块中有效 12345678&#123; let a = 5; var b = 8;&#125;console.log(a);console.log(b);// 控制台输出错误信息：Uncaught ReferenceError：a is not defined 块级作用域可以理解为{ }内的范围，如果存在多层代码块嵌套的情况，内层代码块中声明的变量就不能在外层代码块中调用，相反，外层代码块中声明的变量可以在内层代码块中调用 12345678910&#123; let a = 5; &#123; let b = 8; console.log(a); //正常 &#125; console.log(b); //报错&#125; 先声明后使用使用var声明变量时，可以先使用后声明。 而使用let声明变量时，如果没有声明变量就使用，会出现错误 不允许重复变量名使用var声明变量时，允许在相同作用域中声明多个相同的变量，但是后声明的变量会覆盖先声明的变量 使用let声明变量时，相同的作用域中不允许重复声明变量，否则报错：Uncaught SyntaxError：Identifier ‘a’ has already been declared const命令在ES6中使用const命令声明一个只读变量，该变量一旦声明就不能改变，并且在声明常量同时必须立刻初始化 模板字符串字符串格式化在ES6中，可以将表达式放置在${ } 的大括号中，完成与字符串的拼接功能 1234567// ES5var address = 'beijing';console.log('Welcome to' + address);// ES6const address = 'beijing';console.log(`Welcome to $&#123;address&#125;`); 注意：在使用模板字符串拼接表达式时，需要使用反引号（`）标识（键盘左上角数字左边的标识），而不是单引号（&#39;） 多行字符串在ES5中如果要拼接多行字符串，就需要使用反斜杠（\\n）转移换行 123// ES5var msg = 'How are you? \\n Fine thank you';console.log(msg); 而ES6的模板字符串功能可以简化这一过程 12345// ES6const msg = ` How are you? Fine thank you.`;console.log(msg); 不仅解决了多行字符串的换行问题，而且保留了多行字符串的缩进 关于字符串的函数includes()、startsWith()、endsWith() includes()：返回布尔值，表示是否找到参数字符串 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部 1234let msg = 'Welcome to BeiJing.';console.log(msg.includes('to')); // trueconsole.log(msg.startsWith('Welcome')); // trueconsole.log(msg.endsWith('.')); // true 这三个方法还可以有第二个参数，表示匹配的所以位置 1234let msg = 'Welcome to BeiJing.';console.log(msg.includes('to', 8)); // trueconsole.log(msg.startsWith('BeiJing', 11)); // trueconsole.log(msg.endsWith('Welcome', 7)); // true includes和startsWith方法的第二个参数，均表示从第n个索引位置开始匹配字符串，而endsWith方法的第二个参数表示在前n个字符串中匹配结果 repeat() repeat()：将原来的字符串重复n次 要注意的是，repeat方法的参数不能是负数或Infinity，否则会报错 如果参数是小数，则会被取整 如果参数是0或Nan，则输出一个空字符串 如果参数是字符串，则会被转成数字，转换成功就会输出相应字符串；转换失败了就会输出空字符串 123let msg = 'ha';console.log(msg.repeat('3')); // hahahaconsole.log(msg.repeat('HH')); // 空字符串 箭头函数ES6中，为了更简洁方便地定义函数，可以使用箭头（=&gt;）来定义函数 12const fn = (a,b)=&gt;a+b;fn(3,4); // 7 如果箭头函数不需要参数，可以省略小括号 解构赋值ES6中新增的一种数据处理方式，可以将数组和对象中的值提取出来，对变量进行赋值 对象解构赋值12345678910111213141516// ES5const user = &#123; name: 'Tom', age: 20&#125;const name = user.name;const age = user.age;console.log(name+'-'+age); // Tom-20// ES6const user = &#123; name: 'Tom', age: 20&#125;const &#123;name , age&#125; = user;console.log(`$&#123;name&#125;-$&#123;age&#125;`); // Tom-20 只有变量和属性同名，才能正确赋值 数组解构赋值1234567// 声明一个箭头函数，该函数返回一个数组let fu=()=&gt;[ 'Sean', 30, 'BeiJing']let [name, age, address] = fn(); 数组结构过程中，是根据变量的顺序依次解构数组中的值 如果等号左边数组变量个数大于等号右边数组中值的个数，左边多余的变量会被解构成undefined 如果等号左边数组变量个数小于等号右边数组中值的个数，所有的变量依次赋值 字符串解构赋值12const [a, b, c, d] = 'hello';console.log(`$&#123;a&#125;-$&#123;b&#125;-$&#123;c&#125;-$&#123;d&#125;`); // h-e-l-l","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"1-Node.js","slug":"1-Node-js","date":"2020-07-29T12:56:44.000Z","updated":"2020-08-23T03:53:56.391Z","comments":true,"path":"2020/07/29/1-Node-js/","link":"","permalink":"http://yoursite.com/2020/07/29/1-Node-js/","excerpt":"Node.jsNode.js概述什么是Node.js Node.js不是一门语言，不是库、框架 是一个JavaScript运行时环境 Node.js可以解析和执行JavaScript代码 以前只有浏览器可以解析执行JavaScript 而现在JavaScript可以完全脱离浏览器运行","text":"Node.jsNode.js概述什么是Node.js Node.js不是一门语言，不是库、框架 是一个JavaScript运行时环境 Node.js可以解析和执行JavaScript代码 以前只有浏览器可以解析执行JavaScript 而现在JavaScript可以完全脱离浏览器运行 浏览器中的JavaScript： EcmaScript BOM DOM Node.js中的JavaScript： 没有BOM、DOM EcmaScript 在Node这个JavaScript执行环境中为JavaScript提供了一些服务器级别的操作API 文件读写 网络服务的构建 网络通信 http服务器 …… Node.js特性 事件驱动 非阻塞IO模型（异步） 轻量和高效 Node.js模块化开发JavaScript开发弊端JavaScript在使用时存在两大问题，文件依赖和命名冲突 软件的模块化开发一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行 Node.js的模块化开发规范 Node.js规定一个Javascript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到 模块内部可以使用exports对象进行成员导出，使用require方法导入其他模块 模块成员导出12345678// 在a.js文件中//在模块内部定义变量let version = 1.0;//在模块内部定义方法const sayHi = name =&gt; '你好，$&#123;name&#125;';//向模块外部导出数据exports.version = version;exports.sayHi = sayHi; 模块成员的导入1234567//在b.js文件中//导入模块alet a = require('./a.js');//输出a模块中的version变量console.log(a.version);//调用a模块中的sayHi方法并输出返回值console.log(a.sayHi('张三')); 模块成员导出的另一种方式12module.exports.version = version;module.exports.sayHi = sayHi; exports是module.exports的别名（地址引用关系），导出对象最终以module.exports为准 即当exports和module.exports指向的不是同一个对象时，以module为准 系统模块Node运行环境提供的API，因为这些API都是以模块化的方式进行开发的，所以又称Node运行环境提供的API为系统模块 系统模块 fs 文件操作1const fs = require('fs'); //引入模块 读取文件1234//读取文件内容fs.readFile('文件路径/文件名称'[,'文件编码'], callback(err,doc)&#123; //Code;&#125;); 12345678910//语法示例//读取上一级css目录下的base.cssfs.readFile('../css/base.css', 'utf-8', (err, doc)=&gt;&#123; //如果文件读取发送错误，参数err的值为错误对象，否则err的值为null //doc参数为文件内容 if(err==null)&#123; //在控制台输出文件内容 console.log(doc); &#125;&#125;) 写入文件1fs.writeFile('文件路径/文件名称', '数据', callback); 123456789//语法示例const content = '&lt;h3&gt;正在使用fs.writeFile写入文件内容&lt;/h3&gt;';fs.writeFile('../index.html', content, err=&gt;&#123; if(err != null) &#123; console.log(err); return; &#125; console.log('文件写入成功');&#125;) Node.js全局对象global 在浏览器中全局对象是window，在Node中全局对象是global Node中全局对象下有以下方法，可以在任何地方使用，global可省略 console.log() 在控制台输出 setTimeout() 设置超时定时器 cleatTimeout() 清除超时定时器 setInterval() 设置间歇定时器 clearInterval() 清除间歇定时器 系统模块 path 路径操作为什么要进行路径拼接 不同操作系统的路径分隔符不统一 /public/uploads/ Windows上是 / 或者 \\ Linux 是 / 路径拼接语法1path.join('路径', '路径', ……); 123456//导入path模块const path = require('path');//路径拼接let finialPath = path.join('public', 'source','c.css');//输出结果 public/source/c.cssconsole.log(finialPath); 相对路径VS绝对路径 大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录 在读取文件或者设置文件路径时都会选择绝对路径 使用__dirname（双下划线）获取当前文件所在的绝对路径 1234567const path = require('path');const fs = require('fs');fs.readFile(path.join(__dirname, '01.hello.js'), 'utf-8', function(err, doc)&#123; console.log(err); console.log(doc);&#125;) 第三方模块别人写好的，具有特定功能的，能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一文件夹中，所以又名包 第三方模块有两种存在形式 以js文件的形式存在，提供实现项目具体功能的API接口 以命令行工具形式存在，辅助项目开发 获取第三方模块npmjs.com：第三方模块的存储和分发仓库 npm（node package manager）：node的第三方模块管理工具 下载：npm install 模块名称 卸载：npm uninstall 模块名称 全局安装与本地安装 命令行工具：全局安装 库文件：本地安装 第三方模块 nodemonnodemon是一个命令行工具，用以辅助项目开发 在Node.js中，每次修改文件都要在命令行工具中重新执行该文件，非常繁琐 而nodemon在修改保存后可以自动重新加载该文件 使用步骤 使用npm install nodemon -g 下载并安装在全局 在命令行工具中用nodemon命令替代node 第三方模块 nrmnrm(npm registry manager)：npm下载地址切换工具 npm默认的下载地址在国外，国内下载速度慢 使用步骤 使用npm install nrm -g 查询可用下载地址列表** nrm ls** 切换npm下载地址 nrm use 下载地址名称 第三方模块 Gulp基于node平台开发的前端构建工具 将机械化操作编写任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了 用机器代替手工，提高开发效率 Gulp能做什么 项目上线，HTML、CSS、JS文件压缩合并 语法转换（es6、less……） 公共文件抽离 修改文件浏览器自动刷新 Gulp使用 使用npm install gulp 下载库文件 使用npm install gulp-cli 下载gulp命令行工具 在项目根目录下新建gulpfile.js文件 重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件 在gulpfile.js文件中编写任务 在命令行工具中执行gulp任务 Gulp中提供的方法 gulp.src( )：获取任务要处理的文件 gulp.dest( )：输出文件 gulp.task( )：建立gulp任务 gulp.watch( )：监控文件的变化 12345678const gulp = require('gulp');//使用gulp。task()方法建立任务，第一个参数是任务名称gulp.task('first', ()=&gt; &#123; //获取要处理的文件 gulp.src('./src/css/base.css'); //将处理后的文件输出到dist目录 .pipe(gulp.dest('./dist/css'));&#125;); 12//自动寻找当前目录下的gulpFile.js文件，并执行其中的first任务gulp first Gulp插件 gulp-htmlmin：html文件压缩 gulp-csso：压缩css gulp-babel：JavaScript语法转化 gulp-less：less语法转化 gulp-uglify：压缩混淆JavaScript gulp-file-include：公共文件包含 browsersync：浏览器实时同步 插件网站：www.npmjs.com/package 插件的使用 gulp-htmlmin 压缩html文件 下载 1npm install gulp-htmlmin 引入 12const gulp = require('gulp')const htmlmin = require('gulp-htmlmin'); 使用 12345678gulp.task('minfy', () =&gt; &#123; return gulp.src('src/*.html') .pipe(htmlmin(&#123; // 压缩html文件中的代码时是否压缩空格 collapseWhitespace: true &#125;)) .pipe(gulp.dest('dist'))&#125;) gulp-file-include 公共文件包含 下载 1npm install gulp-file-include 引用 1var fileinclude = require('gulp-file-include') 使用 12345678gulp.task('fileinclude', function()&#123; gulp.src(['index.html']) .pipe(fileinclude(&#123; prefix: '@@'. basepath: '@file' &#125;)) .pipe(gulp.dest('./'));&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"5-同源政策","slug":"5-同源政策","date":"2020-07-27T14:25:13.000Z","updated":"2020-07-27T14:25:13.863Z","comments":true,"path":"2020/07/27/5-同源政策/","link":"","permalink":"http://yoursite.com/2020/07/27/5-%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"4-FormData","slug":"4-FormData","date":"2020-07-27T12:08:21.000Z","updated":"2020-07-27T12:08:21.501Z","comments":true,"path":"2020/07/27/4-FormData/","link":"","permalink":"http://yoursite.com/2020/07/27/4-FormData/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"3-模板引擎","slug":"3-模板引擎","date":"2020-07-26T11:59:04.000Z","updated":"2020-07-26T11:59:04.713Z","comments":true,"path":"2020/07/26/3-模板引擎/","link":"","permalink":"http://yoursite.com/2020/07/26/3-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"2-Ajax异步编程","slug":"2-Ajax异步编程","date":"2020-07-26T02:48:40.000Z","updated":"2020-07-26T02:48:40.973Z","comments":true,"path":"2020/07/26/2-Ajax异步编程/","link":"","permalink":"http://yoursite.com/2020/07/26/2-Ajax%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"5-Nodemon自重启工具","slug":"5-Nodemon自重启工具","date":"2020-07-24T11:43:14.000Z","updated":"2020-07-24T11:48:59.459Z","comments":true,"path":"2020/07/24/5-Nodemon自重启工具/","link":"","permalink":"http://yoursite.com/2020/07/24/5-Nodemon%E8%87%AA%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7/","excerpt":"Nodemon自重启工具在编写调试Node.js项目，修改代码后，需要频繁的手动close掉，然后再重新启动，非常繁琐。现在，我们可以使用nodemon这个工具，它的作用是监听代码文件的变动，当代码改变之后，自动重启。","text":"Nodemon自重启工具在编写调试Node.js项目，修改代码后，需要频繁的手动close掉，然后再重新启动，非常繁琐。现在，我们可以使用nodemon这个工具，它的作用是监听代码文件的变动，当代码改变之后，自动重启。 下载1cnpm install -g nodemon 安装在全局 使用编写代码app.js 123456789101112131415const express = require(\"express\")const path = require('path');const app = express()app.use(express.static(path.join(__dirname, 'public')));app.get('/',function(req,res) &#123; res.send(\"hello world\")&#125;)app.listen(3000,function()&#123; console.log('服务器启动成功')&#125;) 这里使用了express框架。 传统的方法，我们使用node app.js命令，程序将启动。其实，我们刚才下载的nodemon工具也可以用来启动。 1nodemon app.js 我们访问 http://localhost:3000 端口，可以看到hello world。 我们只需要刷新浏览器，就可以看到改动后的内容。 实际上，我们可以看到，nodemon其实也是在调用node命令。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"1-Ajax基础","slug":"1-Ajax基础","date":"2020-07-23T13:19:45.000Z","updated":"2020-07-24T11:40:28.843Z","comments":true,"path":"2020/07/23/1-Ajax基础/","link":"","permalink":"http://yoursite.com/2020/07/23/1-Ajax%E5%9F%BA%E7%A1%80/","excerpt":"Ajax基础传统的网站中存在的问题： 网速慢的情况下，页面加载时间长，用户只能等待 表单提交后，如果一项内容不合格，需要重新填写所有表单内容 页面跳转，重新加载页面，造成资源浪费，增加用户等待时间","text":"Ajax基础传统的网站中存在的问题： 网速慢的情况下，页面加载时间长，用户只能等待 表单提交后，如果一项内容不合格，需要重新填写所有表单内容 页面跳转，重新加载页面，造成资源浪费，增加用户等待时间 Ajax是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验 应用场景 页面上拉加载更多数据 列表数据无刷新分页 表单项离开焦点数据验证 搜索框提示文字下拉列表 运行环境Ajax技术需要运行在网站环境中才能生效 使用Nodejs+express搭建本地服务器 下载安装nodejs和安装express框架 进入这个nodejs中文网链接 下载nodejs 使用express框架搭建本地服务器 安装框架之前先把NPM镜像改成淘宝镜像，在文件夹打开命令行窗口执行命令：*npm config set registry https://registry.npm.taobao.org* 然后全局安装express命令安装工具 输入命令： npm install -g express-generator 再安装express框架 输入命令： *npm install -g express* 安装成功后就可以使用express框架构建项目了 如输入命令： express myStudy -e 创建项目， 再cd 进入该目录，输入命令：npm install 安装组件 ，最后执行命令：npm start 启动项目 运行原理Ajax相当于浏览器发送请求于接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新页面数据，从而提高用户体验 实现步骤 创建Ajax对象 1var xhr = new XMLHttpRequest(); 告诉Ajax请求地址以及请求方式 1xhr.open('get', 'http://www.example.com'); 发送请求 1xhr.send( ); 获取服务端给与客户端的响应数据 123xhr.onload = function()&#123; console.log(xhr.responseText);&#125; 服务器端响应的数据格式在真实项目中，服务器端大多数情况下会以JSON对象作为响应数据的格式，当客户端拿到响应数据时，要将JSON数据和HTML字符串进行拼接，然后将拼接的结果展示在页面中 在http请求与响应的过程中，无论是请求参数还是响应内容，如果是对象类型，最终都会被转换为对象字符串进行传输 1JSON.parse() //将json字符串转换为json对象 请求参数传递 GET请求方式 1xhr.open('get', 'http://www.example.com?name=zhangsan&amp;age=20'); POST请求方式 123xhr.setRequsetHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('name=zhangsan&amp;age=20'); 请求报文在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"4-浏览器私有前缀","slug":"4-浏览器私有前缀","date":"2020-07-23T07:42:13.000Z","updated":"2020-07-23T07:46:25.992Z","comments":true,"path":"2020/07/23/4-浏览器私有前缀/","link":"","permalink":"http://yoursite.com/2020/07/23/4-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80/","excerpt":"","text":"浏览器私有前缀浏览器私有前缀是为了兼容老版本的写法，比较新的浏览器版本不需要添加 私有前缀 -moz-：代表firefox浏览器私有属性 -ms-：代表IE私有属性 -webkit-：代表safari、chrome私有属性 -o-：代表opera私有属性 提倡写法1234-moz-border-radius: 10px;-webkit-border-radius: 10px;-o-border-radius: 10px;border-radius: 10px;","categories":[{"name":"扩展知识","slug":"扩展知识","permalink":"http://yoursite.com/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"私有前缀","slug":"私有前缀","permalink":"http://yoursite.com/tags/%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80/"}]},{"title":"20-3D转换","slug":"20-3D转换","date":"2020-07-23T06:51:41.000Z","updated":"2020-07-23T07:41:16.468Z","comments":true,"path":"2020/07/23/20-3D转换/","link":"","permalink":"http://yoursite.com/2020/07/23/20-3D%E8%BD%AC%E6%8D%A2/","excerpt":"3D转换三维坐标系三维坐标系指立体空间，由三个轴组成 x轴：水平向右 右边是正值，左边是负值 y轴：垂直向下 下面是正值，上面是负值 z轴：垂直屏幕 往外面是正值，往里面是负值","text":"3D转换三维坐标系三维坐标系指立体空间，由三个轴组成 x轴：水平向右 右边是正值，左边是负值 y轴：垂直向下 下面是正值，上面是负值 z轴：垂直屏幕 往外面是正值，往里面是负值 3D移动 translate3d transform: translateX(100px)：仅仅在x轴上移动 transform: translateY(100px)：仅仅在y轴上移动 transform: translateZ(100px)：仅仅在z轴上移动 transform: translate3d(x, y, z)：其中x、y、z分别指要移动的轴方向的距离 xyz不能省略，如果没有就写0 透视 perspective在2D平面产生近大远小视觉立体，但是只是效果二维的 如果想在网页产生3D效果需要透视 模拟人类的视觉位置 透视也称为视距：视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大 透视的单位是像素 透视写在被观察元素的父盒子上 translateZ写在要观察的元素上，进行近大远小的改变 3D旋转 rotate3d3D旋转可以让元素在三维平面内沿着x轴、y轴、z轴或者自定义轴旋转 语法： transform: rotateX(45deg)：沿着X轴正方向旋转45度 transform: rotateY(45deg)：沿着Y轴正方向旋转45度 transform: rotateZ(45deg)：沿着Z轴正方向旋转45度 transform: rotate3d(x, y, z, deg)：沿着自定义轴(x, y, z确定一个轴方向)旋转deg的角度 xyz表示旋转轴的矢量，在坐标系上矢量叠加得到的 左手准则判断元素旋转的方向 左手的拇指指向轴的方向 其余手指的弯曲方向就是该元素沿着该轴正值旋转的方向 3D呈现 transform-style 控制子元素是否开启三维立体环境 transform-style: flat 子元素不开启3d立体空间（默认） transform-style: preserve-3d; 子元素开启立体空间 代码写给父级，但是影响的是子盒子 这个属性很重要","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"19-动画","slug":"19-动画","date":"2020-07-23T05:17:26.000Z","updated":"2020-07-23T06:02:44.707Z","comments":true,"path":"2020/07/23/19-动画/","link":"","permalink":"http://yoursite.com/2020/07/23/19-%E5%8A%A8%E7%94%BB/","excerpt":"动画通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果 相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果","text":"动画通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果 相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果 动画的基本使用 先定义动画 再调用动画 用keyframes定义动画（类似定义类选择器）12345678@keyframes 动画名称 &#123; 0% &#123; width: 100px; &#125; 100% &#123; width: 200px; &#125;&#125; 动画序列 0%是动画的开始，100%是动画的完成，这样的规则就是动画序列 在@keyframes中规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果 可以改变任意多的样式、任意多的次数 用百分比来规定变化发生的时间，或用关键词”from”和”to” 注意： 可以做多个状态的变化 keyframe 关键帧 里面的百分比是整数 百分比是 总的时间的划分 元素使用动画123456789div &#123; width: 200px; heidht: 200px; background-color: pink; /* 调用动画 */ animation-name: 动画名称; /* 持续时间 */ animation-duration: 持续时间;&#125; 动画常用属性 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性，除了animation-play-state属性 animation-name 规定@keyframes动画的名称（必须） animation-duration 规定动画完成一个周期所花费的秒或毫秒默认为0，（必须） animation-timing-function 规定动画的速度曲线，默认为 ease animation-delay 规定动画何时开始，默认为0 animation-iteration-count 规定动画被播放的次数，默认为1，还有 infinite animation-direction 规定动画是否在下一周期逆向播放默认是”normal “，逆播放 alternate animation-play-state 规定动画是否正在运行或暂停默认是”running”，还有”pause” animation-fill-mode 规定动画结束后状态保持 forwards，回到起始 backwards 动画简写属性animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反向 动画起始或结束的状态 简写属性不包含 animation-play-state 暂停动画：animation-play-state: pause; 经常和鼠标经过等配合使用 想要动画走回来而不是跳回来： animation-direction: alternate; 盒子动画结束后，停在结束位置：animation-fill-mode: forwards; 速度曲线细节animation-timing-function: 规定动画的速度曲线，默认是“ ease ” 值 描述 linear 动画从头到尾速度相同，匀速 ease 默认，低速开始，然后加快，结束前变慢 ease-in 以低速开始 ease-out 以低速结束 ease-in-out 以低速开始和结束 steps() 指定了时间函数中的间隔数量（步长） step()配合图片可以实现图片的动画错觉，或者实现打字机效果","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"18-2D转换","slug":"18-2D转换","date":"2020-07-23T04:35:51.000Z","updated":"2020-07-23T05:16:17.406Z","comments":true,"path":"2020/07/23/18-2D转换/","link":"","permalink":"http://yoursite.com/2020/07/23/18-2D%E8%BD%AC%E6%8D%A2/","excerpt":"2D转换转换可以实现元素的位移、旋转、缩放等效果 可以简单理解为变形 移动：translate 旋转：rotate 缩放：scale","text":"2D转换转换可以实现元素的位移、旋转、缩放等效果 可以简单理解为变形 移动：translate 旋转：rotate 缩放：scale 二维坐标系左上角为原点，水平向右为X轴，垂直向下为Y轴 移动 translate改变元素在页面中的位置，类似定位 1234transform: translate(x,y);/* 或者分开写 */transform: translateX(n);transform: translateY(n); translate最大的优点：不会影响其他元素的位置 translate中的百分比单位是相对于自身元素的 对行内标签没有效果 旋转 rotate让元素在二维平面内顺时针或逆时针旋转 1transform: rotate(度数) rotate里面跟度数，单位是deg，比如 rotate(45deg); 角度为正时 顺时针，为负时 逆时针 默认旋转的中心点是元素的中心点 转换中心点 transform-orgin设置元素转换的中心点 1transform-orign: x y; 注意后面的参数x和y用空格隔开 x y 默认转换的中心点是元素的中心点（50% 50%） 还可以给x y 设置像素 或者 方位名词（top bottom left right center） 缩放 scale控制元素的放大和缩小 1transform: scale(x,y); 注意其中的x和y用逗号分隔 transform: scale(1,1)：宽高放大一倍，相当于没有放大 transform: scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于 scale(2,2) transform: scale(0.5, 0.5)：缩小 scale缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子 2D转换综合写法注意： 同时使用多个转换，其格式为：transform: translate() rotate() scale() 其顺序会影响转换的效果（先旋转会改变坐标轴方向 ） 当同时有位移和其他属性的时候，记得要将唯一放到最前","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"18-Web服务器","slug":"2-Web服务器","date":"2020-07-23T04:24:35.000Z","updated":"2020-07-23T04:33:55.258Z","comments":true,"path":"2020/07/23/2-Web服务器/","link":"","permalink":"http://yoursite.com/2020/07/23/2-Web%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"Web服务器什么是服务器服务器（主机）是提供计算服务的设备，是一台计算机 分为：文件服务器、数据库服务器、应用程序服务器、Web服务器 Web服务器一般指网站服务器，指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据，让全世界下载 根据服务器在网络中所在位置不同，又分为本地服务器和远程服务器 将自己的网站上传到远程服务器一个免费的远程服务器（免费空间）：http://free.3v.do 注册账号 记录下主机名、用户名、密码、域名 在该网站上打开FTP管理 利用cutftp软件上传网站到远程服务器 在浏览器输入域名即可访问自己的网站","categories":[{"name":"扩展知识","slug":"扩展知识","permalink":"http://yoursite.com/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"17-CSS3新特性","slug":"17-CSS3新特性","date":"2020-07-23T02:54:50.000Z","updated":"2020-07-23T04:22:34.603Z","comments":true,"path":"2020/07/23/17-CSS3新特性/","link":"","permalink":"http://yoursite.com/2020/07/23/17-CSS3%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"CSS3新特性CSS3现状 新增的CSS3特效有兼容性问题，IE9+才支持 移动端支持由于PC端","text":"CSS3新特性CSS3现状 新增的CSS3特效有兼容性问题，IE9+才支持 移动端支持由于PC端 CSS3新增选择器CSS3新增了选择器，可以更加便捷，自由的选择目标元素 属性选择器 结构伪类选择器 伪元素选择器 属性选择器属性选择器可以根据元素特定属性来选择元素，就不用借助于类或者ID选择器 选择符 简介 E[att] 选择具有att属性的E元素 E[att=”val”] 选择具有att属性且属性值等于val的E元素 E[att^=”val”] 匹配具有att属性且值以val开头的E元素 E[att$=”val”] 匹配具有att属性且值以val结尾的E元素 E[att*=”val”] 匹配具有att属性且值中含有val的E元素 中括号里才是属性选择器，旁边的E是元素选择器，所以这个选择器的权重为11 注意：类选择器、属性选择器、伪类选择器，权重为10 结构伪类选择器主要根据文档结构来选择元素，常用于根据父级选择器里面的子元素 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中的最后一个E元素 E:nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型 E 的第一个 E:last-of-type 指定类型 E 的最后一个 E:nth-of-type(n) 指定类型 E 的第n个 123ul li:first-child &#123; css code;&#125; nth-child(n)nth-child(n) 选择某个父元素的一个或多个特定的子元素 n可以是数字、关键字、公式 n如果是数字：就是选择第n个子元素，里面的数字从1开始 n如果是关键字：even 偶数、odd 奇数 n如果是公式：常见的公式如下（如果n是公式，则从0开始计算，但是第0个元素或者超出了元素个数的会被忽略） 公式 取值 2n 偶数 2n+1 奇数 5n 5、10、15…… n+5 从第5个开始（包含第五个） -n+5 前5个（包含第五个） nth-child和nth-of-type的区别 nth-child 对父元素里面所有孩子排序选择（序号是固定的），先找到第n个孩子，然后看是否和E匹配 nth-of-type 对父元素里面指定子元素进行排序选择，先匹配E，然后根据E找到第n个孩子 伪元素选择器伪元素选择器可以利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构 选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意： before和after创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以称为伪元素 语法：element::before { } before和after必须有content属性 before在父元素内容的前面创建元素，after在父元素内容的后面插入元素 伪元素选择器和标签选择器一样，权重为1，但是和标签选择器搭配使用总计权重为2 CSS3 盒子模型CSS3通过box-sizing **指定盒子模型，有2个值：可指定为content-box、border-box**，这样计算盒子大小的方式就发生了改变 属性值 说明 box-sizing: content-box 默认，盒子大小为width+padding+border box-sizing: border-box 盒子大小为width 如果将盒子模型改为border-box，那么padding和border就不会撑大盒子了（前提是padding和border不会超过width宽度） CSS3 其他特性（了解）CSS3滤镜filter:filter CSS属性将模糊或颜色偏移等图形效果应用于元素 1234filter: 函数();/* 例如：*/filter: blur(5px); /* blur模糊处理 数值越大越模糊 */ 文档网址：http://developer.mozilla.org/zh-CN/docs/Web/CSS/filter 注意数值要加单位 CSS3 calc函数：calc()此CSS函数在声明CSS属性值时执行一些计算 1width: calc(100% - 80px); 括号里面可以使用+ - * / 进行计算 CSS3过渡（重点）过渡动画：是从一个状态渐渐过度到另外一个状态 可以让页面更好看，虽然IE9-不支持，但不会影响页面布局 经常和 :hover 一起搭配使用 1transition: 要过渡的时间 花费时间 运动曲线 何时开始； 属性：想要变化的CSS属性，宽度高度 背景颜色 内外边距都可以，如果想要所有属性都变化过渡，则写all 花费时间：单位是 秒（必须写单位） 比如 0.5s 运动曲线：默认是ease（可以省略） 何时开始：单位是 秒（必须写单位）可以设置延迟触发时间，默认是0s（可以省略） 123456789101112div &#123; width: 200px; height: 200px; background-color: pink; transition: width .5s ease .5s, height .5s; /* 多 */&#125;div:hover &#123; width: 400px; height: 400px&#125; 口诀：谁做过渡给谁加 多个属性变化用逗号分隔","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"6-判断用户终端","slug":"6-判断用户终端","date":"2020-07-22T12:55:07.000Z","updated":"2020-07-22T12:59:22.805Z","comments":true,"path":"2020/07/22/6-判断用户终端/","link":"","permalink":"http://yoursite.com/2020/07/22/6-%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E7%BB%88%E7%AB%AF/","excerpt":"","text":"判断用户终端12345678910111213consloe.log(naciagtor.userAgent);//js的match方法 是否匹配到含有Android或iphone或ipad或iPod的字符串，有则返回含有值的数组，无则返回nullvar isMoblie = navigator.userAgent.match(/android|iphone|ipad|ipod/i);//isMobile中有值返回trueif (isMobile) &#123; //是其中之一，则为手机 location.href = \"URL\";&#125;else&#123; //否则为电脑 location.href = \"URL\";&#125;","categories":[{"name":"扩展知识","slug":"扩展知识","permalink":"http://yoursite.com/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"5-rem适配布局","slug":"5-rem适配布局","date":"2020-07-22T09:49:09.000Z","updated":"2020-07-22T12:52:06.170Z","comments":true,"path":"2020/07/22/5-rem适配布局/","link":"","permalink":"http://yoursite.com/2020/07/22/5-rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80/","excerpt":"rem适配布局rem单位rem（root em）是一个相对单位，类似于em，em是父元素字体大小 不同的是rem的基准是相对于html元素的字体大小 比如：根元素（html）设置font-size=12px；非根元素设置width：2rem；则换成px表示就是24px rem的优点就是可以通过修改html里面的文字大小来改变页面中元素的大小，进行整体控制","text":"rem适配布局rem单位rem（root em）是一个相对单位，类似于em，em是父元素字体大小 不同的是rem的基准是相对于html元素的字体大小 比如：根元素（html）设置font-size=12px；非根元素设置width：2rem；则换成px表示就是24px rem的优点就是可以通过修改html里面的文字大小来改变页面中元素的大小，进行整体控制 媒体查询媒体查询（Media Query）是CSS3新语法 使用@media 查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前很多手机、平板设备都用得到媒体查询 语法规范123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 用@media开头，注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性，必须有小括号包含 meidatype 查询类型将不同的终端设备划分成不同的类型，称为媒体类型 值 说明 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕、平板电脑、智能手机等 关键字关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件 and：可以将多个媒体特性连接到一起，相当于“且” not：排除某个媒体类型，相当于“非”，可省略 only：指定某个特定的媒体类型，可省略 媒体特性每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格，注意要加小括号包含 值 说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域宽度 max-width 定义输出设备中页面最大可见区域宽度 1234/* 在屏幕上，并且最大宽度是800px时，设置想要的样式 */@media screen and (max-width: 800px) &#123; &#125; 注意： screen 还有 and 必须带上不能省略 数字后面必须跟单位 引入资源（理解）当样式比较繁多时，可以针对不同的媒体使用不同stylesheets（样式表） 原理，就是直接在link中判断设备的尺寸，然后引入不同的css文件 语法规范： 1&lt;link rel=\"stylesheet\" media=\"mediatype and|not|only (media feature)\" href=\"mystylesheet.css\"&gt; 建议：媒体查询最好的方法是从小到大 less基础维护CSS的弊端CSS是一门非程序式语言，没有变量、函数、SCOPE（作用域）概念 CSS需要书写大量看似没有逻辑的代码，冗余度比较高 不方便维护及扩展，不利于复用 CSS没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少CSS编写经验而很难写出组织良好且易于维护的CSS代码项目 Less介绍Less（Leaner Style Sheets）是一门CSS扩展语言，也称为CSS预处理器 作为CSS的一种形式的扩展，它并没有减少CSS的功能，而是在现在的CSS语法上，为CSS加入程序式语言的特性 它在CSS的语法基础上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了CSS的编写，并且降低了CSS的维护成本。 Less中文网址：http://lesscss.cn 常见的CSS预处理器：Sass、Less、Stylus Less安装 安装nodejs，可选择版本8.0，网址：http://nodejs.cn/download 检查是否安装成功，使用cms命令，输入“node -v”查看版本 基于nodejs在下安装Less，使用cmd命令，“npm install -g less” 检查是否安装成功，使用cmd命令，“lessc -v”查看版本 Less使用新建一个后缀名为 .less 的文件，在这个less文件里面书写less语句 Less变量 Less编译 Less嵌套 Less运算 less变量变量指没有固定的值，可以改变，因为CSS中的一些颜色和数值等经常使用 1@变量名：值; 变量命名规范 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 less编译本质上，Less包含一套自定义的语法以及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的CSS文件 所以，需要把less文件编译生成为css文件，html页面才能使用 插件Easy LESS插件用来把less文件编译为css文件，安装完毕插件，重启vscode，只要保存一下less文件，就会自动生成css文件 less嵌套123456789.header &#123; width: 200px; height: 200px; background-color: pink; // 嵌套 a &#123; color: red; &#125;&#125; 子元素的样式直接写到父元素里面 1234567891011a &#123; &amp;:hover &#123; color: blue; &#125;&#125;.nav &#123; &amp;::before &#123; content:\" \"; &#125;&#125; 如果有伪类、交集选择器、伪元素选择器，则内层选择器的前面需要加&amp; less运算任何数字、颜色或者变量都可以参与运算。 12345@width: 10px + 5;div &#123; border: @width solid red; width: (@width + 5) * 2;&#125; 12345/* 生成的css */div &#123; border: 15px solid red; width: 40px;&#125; 注意： 乘号（*）和除法（/）的写法 运算符中间左右有个空格隔开：1px + 5 对于两个不同的单位的值之间的计算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果取该单位 rem适配方案 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化，元素尺寸也会发生变化，从而达到等比缩放的适配 rem实际开发适配方案 按照设计稿与设备宽度的比例，动态计算并设置html根标签的font-size大小；（媒体查询） CSS中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为rem为单位的值； rem适配方案技术使用 技术方案1 技术方案2（推荐） less flexible.js 媒体查询 rem rem","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"4-flex布局","slug":"4-flex布局","date":"2020-07-22T03:10:16.000Z","updated":"2020-07-22T09:44:46.539Z","comments":true,"path":"2020/07/22/4-flex布局/","link":"","permalink":"http://yoursite.com/2020/07/22/4-flex%E5%B8%83%E5%B1%80/","excerpt":"flex布局传统布局与flex布局 传统布局 flex弹性布局 兼容性好 操作方便，布局极为简单，移动端应用广泛 布局繁琐 PC端浏览器支持情况较差 局限性，不能在移动端很好的布局 IE11不支持或仅部分支持 建议： PC端页面使用传统布局 移动端且不考虑兼容性，推荐flex布局","text":"flex布局传统布局与flex布局 传统布局 flex弹性布局 兼容性好 操作方便，布局极为简单，移动端应用广泛 布局繁琐 PC端浏览器支持情况较差 局限性，不能在移动端很好的布局 IE11不支持或仅部分支持 建议： PC端页面使用传统布局 移动端且不考虑兼容性，推荐flex布局 布局原理任何一个容器都可以指定为flex布局 当为父盒子设为flex布局后，子元素的float、clear和vertical-align属性将失效 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = flex布局 采用flex布局的元素，称为flex容器（flex container），简称“容器”。它的所有子元素自动成为容器成员，称为flex项目（flex item），简称“项目” flex布局原理：通过给父盒子添加flex属性，控制子盒子的位置和排列方式 常见父项属性以下六个属性是对父元素设置的 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap flex-direction 设置主轴的方向主轴与侧轴在flex布局中，分为主轴和侧轴两个方向，同样叫法：行和列，x轴和y轴 默认主轴方向就是x轴方向，水平向右 默认侧轴方向就是y轴方向，水平向下 属性值flex-direction属性决定主轴的方向（即项目的排列方向） 注意：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴，而子元素是跟着主轴排列的 属性值 说明 row 默认值，从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 justify-content 设置主轴上的子元素排列方式justify-content属性定义了项目在主轴上的对齐方式 注意：使用这个属性之前一定要确定好主轴是哪个 属性值 说明 flex-start 默认值，从头部开始，如果主轴是x轴，则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐（如果主轴是x轴，水平居中） space-around 平分剩余空间 space-between 先两边贴边，再平分剩余空间（重要） flex-wrap 设置子元素是否换行flex布局中，默认的子元素是不换行的，如果装不下，会缩小子元素的宽度，放进父元素里面 默认情况下，项目都排在一条线上（轴线） 属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items 设置侧轴上的子元素排列方式（单行）该属性控制子项在侧轴（默认是y轴）上的排列方式，在子项为单项的时候使用 属性值 说明 flex-start 默认值，从上到下 flex-end 从下到上 center 挤在一起居中（垂直居中） stretch 拉伸（需要去掉高度值） align-content 设置侧轴上的子元素的排列方式（多行）设置子项在侧轴上的排列方式，并且只能用于子项出现换行的情况（多行），在单行下没有效果 属性值 说明 flex-start 默认值，在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴的中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 align-content和align-items的区别 align-items适用于单行情况下，只有上对齐、下对齐、居中和拉伸 align-content适用于换行（多行）情况下，且单行情况下无效，可以设置上对齐、下对齐、居中、拉伸和平均分配剩余空间 flex-flowflex-flow属性是flex-direction和flex-wrap属性的复合属性 1flex-flow: row wrap; 常见子项属性flex属性flex属性定义子项目分配剩余空间，用flex表示占多少份数 123.item &#123; flex: &lt;number&gt;; /* default = 0 */&#125; align-self 控制子项自己在侧轴上的排列方式align-self属性允许单个项目于其他项目不一样的对齐方式，可覆盖align-items属性 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 123span:nth-child(2) &#123; align-self: flex-end;&#125; order属性定义项目的排列顺序数值越小，排列越靠前，默认为0 注意：和z-index不一样","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"3-流式布局","slug":"3-流式布局","date":"2020-07-21T14:51:13.000Z","updated":"2020-07-22T03:53:41.202Z","comments":true,"path":"2020/07/21/3-流式布局/","link":"","permalink":"http://yoursite.com/2020/07/21/3-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/","excerpt":"流式布局 流式布局，就是百分比布局，也称非固定像素布局 通过盒子的宽度设置成百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充 流式布局方式是移动web开发使用比较常见的布局方式","text":"流式布局 流式布局，就是百分比布局，也称非固定像素布局 通过盒子的宽度设置成百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充 流式布局方式是移动web开发使用比较常见的布局方式 max-width 最大宽度（max-height 最大高度） min-width 最小宽度（min-height 最小高度） 一般最小页面宽度为320px 123456body &#123; width: 100%; min-width: 320px; max-width: 640px; margin: 0 auto;&#125; 二倍精灵图做法 在firework里面把精灵图等比例缩放为原来的一半 之后根据大小 测量坐标 注意代码里面background-size也要写：精灵图原来宽度的一半","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"2-移动端开发","slug":"2-移动端开发","date":"2020-07-21T09:37:10.000Z","updated":"2020-07-21T14:49:28.180Z","comments":true,"path":"2020/07/21/2-移动端开发/","link":"","permalink":"http://yoursite.com/2020/07/21/2-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/","excerpt":"移动端开发移动端开发选择 单独制作移动端页面（主流） 响应式页面兼容移动端","text":"移动端开发移动端开发选择 单独制作移动端页面（主流） 响应式页面兼容移动端 单独移动端页面淘宝：m.taobao.com 通常情况下，网址域名前加m（mobile）可以打开移动端，通过判断设备，如果是移动设备打开，则跳到移动端页面 响应式兼容PC移动端三星官网：www.samsung/com/cn 通过判断屏幕宽度来改变样式，以适应不同终端 缺点：制作麻烦，需要花很大精力调兼容性问题 移动端技术解决方案移动端浏览器移动端浏览器基本以Webkit内核为主，因此我们就考虑Webkit兼容性问题 可以放心使用H5标签和C3样式 同时浏览器的私有前缀我们只需要考虑添加Webkit即可 CSS初始化 normalize.css移动端CSS初始化推荐使用normalize.css/ Normalize.css：保护了有价值的默认值 Normalize.css：修复了浏览器的bug Normalize.css：是模块化的 Normalize.css：拥有详细的文档 官网地址：http://necolas.github.io/normalize.css/ CSS3盒子模型 box-sizing 传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型：盒子的宽度 = CSS中设置的宽度width里面包含了border和padding 也就是说，CSS3中的盒子模型，padding和border不会撑大盒子了 12345678div &#123; box-sizing: border-box; /* 这句话让盒子变成CSS3盒子模型*/ width: 100px; height: 100px; padding: 10px; border: 10px solid red; /*最后盒子只有100*100大小*/&#125; 移动端可以全部CSS3盒子模型 PC端如果需要兼容，就用传统模型，如果不考虑兼容，就选择CSS3 特殊样式123456789101112/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除 设置transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在IOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-apperance: none;/*禁用长按页面时弹出菜单*/img, a &#123; -webkit-touch-callout: none; &#125; 移动端常见布局 单独制作移动端页面（主流） 流式布局（百分比布局） flex弹性布局（推荐） less+rem+媒体查询布局 混合布局 响应式页面兼容移动端 媒体查询 bootstrap","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"1-移动端基础","slug":"1-移动端基础","date":"2020-07-21T07:18:32.000Z","updated":"2020-07-21T14:49:43.665Z","comments":true,"path":"2020/07/21/1-移动端基础/","link":"","permalink":"http://yoursite.com/2020/07/21/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%BA%E7%A1%80/","excerpt":"移动端基础浏览器现状国内的浏览器都是根据Webkit修改的内核，国内尚无自主研发的内核。 兼容移动端主流浏览器，处理Webkit内核浏览器即可","text":"移动端基础浏览器现状国内的浏览器都是根据Webkit修改的内核，国内尚无自主研发的内核。 兼容移动端主流浏览器，处理Webkit内核浏览器即可 移动端调试方法 Chrome DevTools（谷歌浏览器的模拟手机调试） 搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器 使用外网服务器，直接IP或者域名访问 视口视口就是浏览器显示页面内容的屏幕区域，视口可以分为布局视口、视觉视口和理想视口 布局视口 layout viewport 一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题 IOS、Android基本都将这个视口分辨率设置为980px，所以PC上的网页大多能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页 视觉视口 visual viewport 用户正在看的网站的区域 可以通过缩放操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度 理想视口 ideal viewport 为了使网站在移动端有最理想的浏览和阅读宽度而定 理想视口，对设备来讲，是最理想的视口尺寸 需要手动填写meta视口标签通知浏览器操作 meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，设备有多宽，布局视口就多宽 meta视口标签1&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 属性 说明 width 宽度设置的是viewport宽度可以设置 device-width 特殊值 initial-scale 初始缩放比，大于0的数字 maximum-scale 最大缩放比，大于0的数字 minimum-scale 最小缩放比，大于0的数字 user-scalable 用户是否可以缩放，yes或no（1或0） 标准的viewport设置 视口宽度和设备保持一致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许缩放比例1.0 最小允许缩放比例1.0 二倍图物理像素&amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的 开发时的1px不是一定等于一个物理像素的 PC端页面，1个px等于1个物理像素，但是移动端不尽相同 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比 PC端和早前的手机屏幕/普通手机屏幕：1CSS像素 = 1 物理像素 Retina（视网膜屏幕）是一种显示技术，可以把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度 多倍图 对于一张50px*50px的图片，在手机Retina屏中打开，按照物理像素比会方法倍数，会造成图片模糊 在标准的viewport设置中，使用倍图提高图片质量，解决在高清设备中的模糊问题 通常使用二倍图 背景图片注意缩放问题 背景缩放 background-size1background-size: 背景图片宽度 背景图片高度; 只写一个参数，肯定是宽度，高度省略并跟宽度更比例缩放 单位：长度、百分比、cover、contain cover：把背景图片扩展至足够大，使背景图片完全覆盖背景区域，宽高等比例，可能造成图片显示不全 contain：把背景图片扩展至最大尺寸，以使宽度和高度完全适应内容区域，宽高等比例，可能造成空白区域 背景图片二倍图有一个50px*50px的盒子需要一个背景图，根据分析这个图片要准备两倍，即100px*100px 所以需要把这个背景图片缩放一半，即50*50 1234567div &#123; width: 50px; height: 50px; border: 1px solid red; background: url(images/app100.jpg) no-repeat; background-size: 50px 50px;&#125; 多倍图切图 cutterman利用PS里的cutterman，导出多倍图","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"1-VUE","slug":"1-VUE","date":"2020-07-19T13:07:24.000Z","updated":"2020-07-19T13:07:24.111Z","comments":true,"path":"2020/07/19/1-VUE/","link":"","permalink":"http://yoursite.com/2020/07/19/1-VUE/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"1-PHP","slug":"1-PHP","date":"2020-07-19T11:02:44.000Z","updated":"2020-07-19T12:20:00.475Z","comments":true,"path":"2020/07/19/1-PHP/","link":"","permalink":"http://yoursite.com/2020/07/19/1-PHP/","excerpt":"PHP框架123&lt;?php //内容?&gt;","text":"PHP框架123&lt;?php //内容?&gt; 设置编码格式首先要给php设置编码格式，否则中文会乱码 123&lt;?php header('content-type:text/html;charset=utf-8');?&gt; 变量12345678910111213141516&lt;?php //定义变量 var name = 'jack'; $name = 'jack'; //输出变量 echo $name; //换行 echo '&lt;br&gt;'; //php中拼接字符串用‘.’ for($i=0;$i&lt;10;$i++)&#123; echo '&lt;br&gt;'; echo '循环第'.$i.'次'; &#125;?&gt; 数组123456789101112131415161718192021222324252627282930313233343536373839&lt;?php//定义数组 $foodArr = array('米饭','鸡蛋','菜花'); //获取数组元素 echo $foodArr[0]; //遍历数组 for($i=0;$i&lt;count($foodArr);$i++)&#123; echo '&lt;br&gt;'; echo $foodArr[i]; &#125; //定义键值对 $person = array('name'=&gt;'吴京','film'=&gt;'战狼'); //获取键值对 echo $person['film']; //遍历 foreach($person as $key =&gt; $value)&#123; echo $key.'------'.$value.'&lt;br&gt;'; &#125; //二维数组 $starArr = array( array('name'=&gt;'刘德华','film'=&gt;'无间道') array('name'=&gt;'吴京','film'=&gt;'战狼') array('name'=&gt;'黄渤','film'=&gt;'疯狂石头') ); //获取元素 echo $starArr[2]['film']; //遍历 for($i=0;$i&lt;count($starArr);$i++)&#123; echo '明星：'.$starArr[$i]['name'].'出演了:'.$starArr[$i]['film'].'&lt;br&gt;'; &#125;?&gt; 引入php文件123&lt;?php include '/data.php';?&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"17-动画函数封装","slug":"17-动画函数封装","date":"2020-07-19T02:50:03.000Z","updated":"2020-07-20T14:15:32.500Z","comments":true,"path":"2020/07/19/17-动画函数封装/","link":"","permalink":"http://yoursite.com/2020/07/19/17-%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85/","excerpt":"动画函数封装动画实现原理核心原理：通过定时器setInterval()不断移动盒子位置","text":"动画函数封装动画实现原理核心原理：通过定时器setInterval()不断移动盒子位置 实现步骤： 获得盒子当前位置 让盒子在当前位置加上1个移动距离 利用定时器不断重复这个操作 加一个结束定时器的条件 注意此元素需要添加定位，才能使用element.style.left 动画函数简单封装注意函数需要传递两个参数，动画对象和移动到的距离 12345678function animate(obj, target) &#123; var timer = setInterval(function()&#123; if (obj.offsetLeft &gt;= target) &#123; clearInterval(timer); &#125; obj.style.left = obj.offsetLeft + 1 + 'px'; &#125;, 30);&#125; 动画函数给不同元素记录不同定时器如果多个元素都使用一个动画函数，每次都要var声明定时器。可以给不同元素使用不同定时器 核心原理：利用JS是一门动态语言，可以方便的给当前对象添加属性 12345678function animate(obj, target) &#123; obj.timer = setInterval(function()&#123; if (obj.offsetLeft &gt;= target) &#123; clearInterval(obj.timer); &#125; obj.style.left = obj.offsetLeft + 1 + 'px'; &#125;, 30);&#125; 缓动效果原理缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来 思路： 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来 核心算法：（目标值 - 现在的位置）/ 10 作为每次移动的距离 步长 停止的条件：让当前盒子位置等于目标位置就停止定时器 动画函数添加回调函数回调函数原理：函数作为一个参数，将这个函数作为参数传到另一个函数里，当那个函数执行完后，再执行传进去的这个函数，这个过程叫回调 回调函数写的位置：定时器结束的位置 动画函数封装到单独JS文件里面因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可 节流阀防止轮播图按钮连续点击造成播放过快 节流阀的目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发 核心实现思路：利用回调函数，添加一个变量控制，锁住函数和解锁函数 123456789var flag = true; //开始设置一个变量 if (flag) &#123; //关闭水龙头 flag = false; // do someting&#125;//利用回调函数 动画执行完毕flag = true; //打开水龙头","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"16-PC端网页特效","slug":"16-PC端网页特效","date":"2020-07-18T14:00:06.000Z","updated":"2020-07-19T02:49:35.695Z","comments":true,"path":"2020/07/18/16-PC端网页特效/","link":"","permalink":"http://yoursite.com/2020/07/18/16-PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/","excerpt":"PC端网页特效元素偏移量 offset 系列offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等 获得元素距离带有定位父元素的位置 获得元素自身的大小（宽度高度） 注意：返回的数值都不带单位","text":"PC端网页特效元素偏移量 offset 系列offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等 获得元素距离带有定位父元素的位置 获得元素自身的大小（宽度高度） 注意：返回的数值都不带单位 offset系列常用属性： offset系列属性 作用 element.offsetParent 返回作为该元素带有定位的父级元素，如果父级都没有定位则返回body element.offsetTop 返回元素相对带有定位父元素上方的偏移 element.offsetLeft 返回元素相对带有定位父元素左边框的偏移 element.offsetWidth 返回自身包括padding、边框、内容区的宽度，返回数值不带单位 element.offsetHeight 返回自身包括padding、边框、内容区的高度，返回数值不带单位 offset 与 style 区别 offset style offset可以得到任意样式表中的样式值 style只能得到行内样式表中的样式值 获得的数值是没有单位的 获得的是带有单位的字符串 offsetWidth包含padding+border+width style.width获得不包含padding和border的值 offsetWidth等属性是只读属性，只能获取不能赋值 style.width是可读写属性，可以获取也可以赋值 想要获取元素大小位置，用offset更合适 想要给元素更改值，则需要用style改变 元素可视区client系列client系列的相关属性获取元素可视区的相关信息，可以动态的得到该元素的边框大小、元素大小 client系列属性 作用 element.clientTop 返回元素上边框的大小 element.clientLeft 返回元素左边框的大小 element.clientWidth 返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位 element.clientHeight 返回自身包括padding、内容区的高度，不含边框，返回数值不带单位 元素滚动scroll系列scroll系列的相关属性可以动态的得到该元素的大小、滚动距离 scroll系列属性 作用 element.scrollTop 返回被卷去 的上侧距离，返回数值不带单位 element.scrollLeft 返回被卷去 的左侧距离，返回数值不带单位 element.scrollWidth 返回自身实际的宽度，不含边框，数值不带单位 element.scrollHeight 返回自身实际的高度，不含边框，数值不带单位 注意：页面滚动距离通过 window.pageYOffset 获得 mouseenter 和mouseover 的区别 当鼠标移动到元素上时会触发mouseenter事件 类似mouseover mouseover鼠标经过自身盒子会触发，经过子盒子还会触发 mouseenter只会经过自身盒子触发 因为mouseenter不会冒泡 跟mouseenter搭配的，鼠标离开mouseleave也不会冒泡","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"特效","slug":"特效","permalink":"http://yoursite.com/tags/%E7%89%B9%E6%95%88/"}]},{"title":"15-history对象","slug":"15-history对象","date":"2020-07-18T13:53:40.000Z","updated":"2020-07-18T13:58:57.657Z","comments":true,"path":"2020/07/18/15-history对象/","link":"","permalink":"http://yoursite.com/2020/07/18/15-history%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"history对象windo对象提供了一个history对象，与浏览器历史记录进行交互，该对象包含用户（在浏览器窗口中）访问过的URL history对象方法 作用 back() 后退功能 forward() 前进功能 go(参数) 前进后退功能参数如果是1，前进一个页面参数如果是-1，后退一个页面","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"14-navigator对象","slug":"14-navigator对象","date":"2020-07-18T13:44:20.000Z","updated":"2020-07-18T13:53:14.975Z","comments":true,"path":"2020/07/18/14-navigator对象/","link":"","permalink":"http://yoursite.com/2020/07/18/14-navigator%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"navigator对象navigator对象包含有关浏览器的信息，有很多属性，最常用的是userAgent，该属性可以返回客户机发送服务器的user-agent头部的值 下面前端代码可以判断用户用哪个终端打开页面，实现跳转： 12345if ( (navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Window Phone)/i)))&#123; window.location.href = \" \"; //手机&#125;else &#123; window.location.href = \" \"; //电脑&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"13-location对象","slug":"13-location对象","date":"2020-07-18T12:50:11.000Z","updated":"2020-07-18T13:43:57.283Z","comments":true,"path":"2020/07/18/13-location对象/","link":"","permalink":"http://yoursite.com/2020/07/18/13-location%E5%AF%B9%E8%B1%A1/","excerpt":"location对象window对象提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL，因为这个属性返回的是一个对象，所以将这个属性也称为location对象 URL统一资源定位符（Uniform Resource Locator ，URL）是互联网上标准资源的地址，互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它","text":"location对象window对象提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL，因为这个属性返回的是一个对象，所以将这个属性也称为location对象 URL统一资源定位符（Uniform Resource Locator ，URL）是互联网上标准资源的地址，互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它 URL的一般语法格式： 123protocal://host[:port]/path/[?query]#fragmenthttps://www.baidu.com/index.html?name=andy&amp;age=19#link 组成 说明 protocol 通信协议，常用的 http, ftp, maito等 host 主机（域名） port 端口号 可选，省略时使用方案的默认端口如http的默认端口为80 path 路径，由零或多个‘/’符号隔开的字符串一般用来表示主机上的一个目录或文件地址 query 参数，以键值对的形式，通过&amp;符号分隔开 fragment 片段，#后面内容常见于链接、锚点 location对象的属性 location对象属性 返回值 location.href 获取或设置整个URL location.host 返回主机（域名） location.port 返回端口号，如果未写则返回空字符串 location.pathname 返回路径 location.search 返回参数 location.hash 返回片段 #后面内容常见于链接、锚点 location对象的方法 location对象方法 返回值 location.assign() 跟href一样，可以跳转页面（也称为重定向页面） location.replace() 替换当前页面，因为不记录历史，所以不能后退页面 location.reload() 重新加载页面，相当于刷新或者F5如果参数为true，强制刷新 ctrl+F5","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"12-JS执行队列","slug":"12-JS执行队列","date":"2020-07-18T02:53:42.000Z","updated":"2020-07-18T12:49:36.927Z","comments":true,"path":"2020/07/18/12-JS执行队列/","link":"","permalink":"http://yoursite.com/2020/07/18/12-JS%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/","excerpt":"JS执行队列JS是单线程JavaScript语言的一大特点就是单线程，同一时间只能做一件事 单线程意味着所有任务需要排队，导致的问题是：如果JS执行时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉","text":"JS执行队列JS是单线程JavaScript语言的一大特点就是单线程，同一时间只能做一件事 单线程意味着所有任务需要排队，导致的问题是：如果JS执行时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉 同步和异步HTML5提出Web Worker标准，允许JS脚本创建多个线程，于是JS中出现了同步和异步 同步前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序一致 异步执行某一个任务的同时，允许其他任务一起执行 同步任务同步任务都在主线程上执行，形成一个执行栈 异步任务JS的异步是通过回调函数实现的 一般而言，异步任务有以下三种类型： 普通事件，如click、resize 资源加载，如load、error 定时器，包括setInterval、setTimeout 异步任务相关回调函数添加到任务队列中（也称消息队列） JS执行机制 先执行执行栈中的同步任务 异步任务（回调函数）放入任务队列中 一旦执行栈中的所有同步任务执行完毕，系统会依次按序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"11-window对象常见事件","slug":"11-window对象常见事件","date":"2020-07-17T12:25:32.000Z","updated":"2020-07-17T14:45:52.549Z","comments":true,"path":"2020/07/17/11-window对象常见事件/","link":"","permalink":"http://yoursite.com/2020/07/17/11-window%E5%AF%B9%E8%B1%A1%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6/","excerpt":"window对象常见事件窗口加载事件123window.onload = function() &#123; &#125;// 或者window.addEventListener(\"load\", function()&#123; &#125;); window.onload是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件、CSS文件），就调用的处理函数","text":"window对象常见事件窗口加载事件123window.onload = function() &#123; &#125;// 或者window.addEventListener(\"load\", function()&#123; &#125;); window.onload是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件、CSS文件），就调用的处理函数 注意： 有了window.onload就可以把JS写到页面元素上面甚至外部 window.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准 如果使用addEventListener则没有限制 1document.addEventListener('DOMContentLoaded', function()&#123; &#125;) DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表、图片、flash 如果页面的图片很多，从用户访问到onload触发可能需要较长事件，交互效果就不能实现，必然影响用户体验，此时用DOMContentLoaded事件比较合适 load等页面内容全部加载完毕，包含页面DOM元素、图片、flash、css DOMContentLoaded是DOM加载完毕，不包含图片、flash、css等就可以执行，加载速度比load更快，执行更快 调整窗口大小事件123window.onresize = function() &#123; &#125;// 或者window.addEventListener('resize', function() &#123; &#125;) window.onresize 是调整窗口大小加载事件，当触发时就调用处理函数 注意： 只要窗口大小发生像素级变化，就会触发这个事件 常利用这个事件完成响应式布局，window.innerWidth属性可获取当前屏幕的宽度 定时器setTimeout()定时器12window.setTimeout(调用函数，[延迟的毫秒数]);// window可省略 setTimeout()方法用于设置一个定时器，该定时器在定时到期后执行调用函数 注意： window可省略 这个调用函数可以直接写函数，或者写函数名调用或者采取字符串‘函数名（）’三种形式，第三种不推荐 延迟的毫秒数省略默认是0，如果写，必须是毫秒 因为定时器可能有很多，所有经常给定时器赋值一个标识符 停止setTimeout()定时器1window.clearTimeout(timeoutID) clearTimeout()方法取消了先前通过调用setTimeout()建立的定时器 注意： window可以省略 里面的参数就是定时器的标识符 setInerval() 定时器1window.setInterval(回调函数[, 间隔的毫秒数]); setInterval()方法重复调用一个函数，每隔这个时间就去调用一次回调函数 注意： window可省略 这个调用函数可以直接写函数，或者写函数名调用或者采取字符串‘函数名（）’三种形式，第三种不推荐 延迟的毫秒数省略默认是0，如果写，必须是毫秒 因为定时器可能有很多，所有经常给定时器赋值一个标识符 停止setInterval()定时器1window.clearInterval(intervalID); clearInterval()方法取消了先前通过调用setInterval()建立的定时器 注意： window可省略 里面的参数就是定时器的标识符","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"10-BOM","slug":"10-BOM","date":"2020-07-17T12:14:04.000Z","updated":"2020-07-17T12:25:49.303Z","comments":true,"path":"2020/07/17/10-BOM/","link":"","permalink":"http://yoursite.com/2020/07/17/10-BOM/","excerpt":"BOMBOM（Browser Object Model）浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心是window DOM BOM 文档对象模型 浏览器对象模型 DOM把文档当作一个对象 把浏览器当作一个对象 DOM的顶级对象是document BOM的顶级对象是window DOM学习的是操作页面元素 BOM学习的是浏览器窗口交互 DOM是W3C标准规范 BOM是浏览器厂商在各自浏览器上定义的兼容性较差","text":"BOMBOM（Browser Object Model）浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心是window DOM BOM 文档对象模型 浏览器对象模型 DOM把文档当作一个对象 把浏览器当作一个对象 DOM的顶级对象是document BOM的顶级对象是window DOM学习的是操作页面元素 BOM学习的是浏览器窗口交互 DOM是W3C标准规范 BOM是浏览器厂商在各自浏览器上定义的兼容性较差 BOM的构成BOM比DOM更大，它包含DOM window对象是浏览器的顶级对象 它是JS访问浏览器窗口的一个接口 它是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用时可以省略window","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"9-事件对象","slug":"9-事件对象","date":"2020-07-16T14:48:26.000Z","updated":"2020-07-17T12:08:13.701Z","comments":true,"path":"2020/07/16/9-事件对象/","link":"","permalink":"http://yoursite.com/2020/07/16/9-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/","excerpt":"事件对象什么是事件对象123eventTarget.onclick = function(event) &#123;&#125;eventTarget.addEventListener('click', function(event)&#123;&#125;)// 这个event就是事件对象，可以自命名e或者evt 事件发生后，跟事件相关的一系列信息数据的集合都放在这个对象里面，这个对象就是事件event，有很多属性和方法 这个event是个形参，不需要传递实参，当注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）","text":"事件对象什么是事件对象123eventTarget.onclick = function(event) &#123;&#125;eventTarget.addEventListener('click', function(event)&#123;&#125;)// 这个event就是事件对象，可以自命名e或者evt 事件发生后，跟事件相关的一系列信息数据的集合都放在这个对象里面，这个对象就是事件event，有很多属性和方法 这个event是个形参，不需要传递实参，当注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数） 事件对象的常见属性和方法 事件对象属性方法 说明 e.target 返回触发事件的对象（标准） e.srcElement 返回触发事件的对象（非标准 IE6-8使用） e.type 返回事件的类型，比如click mouseover，不带on e.cancelBubble 该属性阻止冒泡（非标准 IE6-8使用） e.returnValue 该属性阻止默认事件（非标准，IE6-8，比如不让链接跳转） e.preventDefault() 该方法阻止默认事件（标准） e.stopPropagation() 阻止冒泡（标准） e.target返回的是触发事件的对象 this 返回的是绑定事件的对象 阻止事件冒泡 标准写法： 1e.stopPropagation() 非标准写法：IE6-8利用事件对象cancelBubble属性 1e.canecelBubble = true; 兼容性解决方案： 12345if (e &amp;&amp; e.stopPropagation)&#123; e.stopPropagation();&#125;else&#123; window.event.cancelBubble = true;&#125; 事件委托事件委托也称为时间代理，在jQuery成为事件委派 事件委托的原理（重要）不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点 事件委托的作用只操作一次DOM，提高程序性能 鼠标事件禁止鼠标右键菜单contextmenu 主要控制应该何时显示上下文菜单，主要用于取消默认的上下文菜单 123document.addEventListener('contextmenu', function(e)&#123; e.preventDefault;&#125;) 禁止鼠标选中selectstart 开始选中 123document.addEventListener('selectstart', function(e)&#123; e.preventDefault;&#125;) 鼠标事件对象 鼠标事件对象 说明 e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标 e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标 e.pageX 返回鼠标相对于文档页面的X坐标 e.pageY 返回鼠标相对于文档页面的Y坐标 e.screenX 返回鼠标相对于电脑屏幕的X坐标 e.screenY 返回鼠标相对于电脑屏幕的Y坐标 键盘事件常用键盘事件 键盘事件 触发条件 onkeyup 某个键盘按键被松开时触发 onkeydown 某个键盘按键被按下时触发 onkeypress 某个键盘按键被按下时触发 但是不识别功能键 比如 crtl shift 箭头 等 注意： 三个事件的执行顺序：keydown &gt; keypress &gt; keyup 如果使用addEventListener不需要加on keydown和keypress在文本框里的特定：它们两个事件触发的时候，文字还没有落入文本框中 键盘事件对象 键盘事件对象 属性 说明 keyCode 返回该键的ASCⅡ 值 注意： onkeydown和 onkeyup 不区分字母大小写 onkeypress区分字母大小写 实际开发中更多使用keydown和keyup，能识别所有键 而keypress不识别功能键，但keyCode属性能区分大小写，返回不同ASCⅡ值","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"8-DOM事件流","slug":"8-DOM事件流","date":"2020-07-16T14:11:09.000Z","updated":"2020-07-16T14:47:54.212Z","comments":true,"path":"2020/07/16/8-DOM事件流/","link":"","permalink":"http://yoursite.com/2020/07/16/8-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/","excerpt":"DOM事件流事件流描述的是从页面中接收事件的顺序 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流","text":"DOM事件流事件流描述的是从页面中接收事件的顺序 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流 DOM事件流分为3个阶段： 捕获阶段 当前目标阶段 冒泡阶段 事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层的过程 事件捕获：由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程 注意： JS代码中只能执行捕获或者冒泡其中的一个阶段 onclick和attachEvent只能得到冒泡阶段 addEventListener(type, listener[, useCapture]) 第三个参数如果是true，表示事件捕获阶段调用事件处理程序，如果是false，表示在事件冒泡阶段调用事件处理程序 实际开发中更关注事件冒泡 有些事件没有冒泡，比如 onblur、onfocus、onmouseenter、onmouseleave","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"7-注册事件","slug":"7-注册事件","date":"2020-07-16T13:30:04.000Z","updated":"2020-07-16T14:34:35.688Z","comments":true,"path":"2020/07/16/7-注册事件/","link":"","permalink":"http://yoursite.com/2020/07/16/7-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6/","excerpt":"注册事件概述给元素添加事件，称为注册事件或绑定事件 注册事件有两种方式：传统方式和方法监听方式","text":"注册事件概述给元素添加事件，称为注册事件或绑定事件 注册事件有两种方式：传统方式和方法监听方式 传统注册方式 利用on开头的事件 &lt;button onclick=\"alert('hi')\"&gt;&lt;/button&gt; 123* ~~~javascript btn.onclick&#x3D;function() &#123; &#125; 特定：注册事件的唯一性 同一元素同一事件只能设置一个处理函数，最后注册的处理函数会覆盖前面注册的处理函数 方法监听注册方式 W3C标准推荐方式 addEventListener()方法 IE9之前不支持，可用attachEvent()代替 特定：同一元素同一事件可以注册多个监听器 按注册顺序依次执行 addEventistener 事件监听方式1eventTarget.addEventListener(type, listener[, useCapture]) eventTarget.addEventListener()方法将指定的监听器注册到evenTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数 该方法接收三个参数： type：事件类型字符串，比如click、mouseover，注意不带on listener：事件处理函数，事件发生时会调用该监听函数 useCapture：可选参数，是一个布尔值，默认false 当为true时，处于DOM事件流的捕获阶段，从上往下 当为空或者false时，处于DOM事件流的冒泡阶段，从下往上 attachEvent 事件监听方式（不推荐）1eventTarget.attachEvent(eventNameWithOn, callback) 接收两个参数： eventNameWithOn：事件类型字符串，onclick、onmouseover，这里要带on callback：事件处理函数，当目标触发事件时回调函数被调用 删除事件传统注册方式eventTarget.onclick = null; 方法监听注册方式 eventTarget.removeEventListener(type, listener[, useCapture]); &lt;!--￼3--&gt; eventTarget.detachEvent(eventNameWithOn, callback);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"6-DOM重点总结","slug":"6-DOM重点总结","date":"2020-07-16T12:47:43.000Z","updated":"2020-07-16T12:57:54.062Z","comments":true,"path":"2020/07/16/6-DOM重点总结/","link":"","permalink":"http://yoursite.com/2020/07/16/6-DOM%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"DOM重点总结创建 document. write innerHTML createElement","text":"DOM重点总结创建 document. write innerHTML createElement 增 appendChild( ) insertBefore( ) 删 removeChild 改主要改DOM的元素属性，DOM元素的内容、属性、表达值 元素属性：src、href、title 普通元素内容：innerHTML、innerText 表单元素：value、type、disable 元素样式：style、calssName 查主要获取查询DOM的元素 DOM提供的API：getElementById、getElementsByTagName H5的新方法：querySelector、querySelectorAll 利用节点操作获取元素：父（parentNode）、子（children）、兄（perviousElementSibling、nextElementSibling） 属性操作主要针对自定义属性 setAttribute：设置DOM的属性值 getAttribute：得到DOM的属性值 removeAttribute：移除属性 事件操作给元素注册事件，采取 事件源. 事件类型 = 事件处理程序 鼠标事件 触发条件 onclick 鼠标点击左键 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动 onmouseup 鼠标弹起 onmousedown 鼠标按下","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"5-节点操作","slug":"5-节点操作","date":"2020-07-16T07:13:48.000Z","updated":"2020-07-16T12:46:06.770Z","comments":true,"path":"2020/07/16/5-节点操作/","link":"","permalink":"http://yoursite.com/2020/07/16/5-%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/","excerpt":"节点操作通常获取元素有两种方式 利用DOM提供的方法获取元素 document.getElementById() document.getElementByTagName() document.querySelector 等 逻辑性不强、繁琐 利用节点层次关系获取元素 利用父子兄弟关系获取 逻辑性强， 但是兼容性稍差","text":"节点操作通常获取元素有两种方式 利用DOM提供的方法获取元素 document.getElementById() document.getElementByTagName() document.querySelector 等 逻辑性不强、繁琐 利用节点层次关系获取元素 利用父子兄弟关系获取 逻辑性强， 但是兼容性稍差 节点概述网页中所有内容都是节点（标签、属性、文本、注释等） HTML DOM树中的所有节点均可通过JS进行访问，所有HTML元素（节点）均可被修改、创建、删除 一般，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）三个基本属性 元素节点 nodeType 为 1 属性节点 nodeType 为 2 文本节点 nodeType 为 3（文本节点包括文字、空格、换行等） 实际开发中，节点操作主要操作的是元素节点 节点层级利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系 父级节点1node.parentNode parentNode属性可返回某个节点的父节点，注意是最近的一个父节点 如果指定的节点没有父节点则返回null 子节点 12parentNode.childNodes** 得到的是一个集合 ** parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合 注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等 如果只想获得元素节点，需要专门处理，所以一般不提倡使用childNodes 1234567var ul = document.querySelector('ul');for(var i=0; i&lt;ul.childNodes.length; i++)&#123; if(ul.childNodes[i].nodeType == 1)&#123; //当nodeType为1时，为元素节点 console.log(ul.childNodes[i]); &#125;&#125; 1parentNode.children parentNode.children 获取所有的子元素节点，实际常用 1parentNode.firstChild firstChild返回第一个子节点，找不到则返回null，包含所有节点 1parentNode.lastChild lastChild返回最后一个子节点，找不到则返回null，包含所有节点 1parentNode.firstElementChild firstElementChild 返回第一个子元素节点，找不到返回null 1parentNode.lastElementChild lastElementChild 返回最后一个子元素节点，找不到返回null 注意：(5)(6)有兼容性问题，IE9以上才支持 解决方案： 如果想要第一个子元素节点，而考虑兼容，可以使用 1parentNode.children[0] 如果想要最后一个子元素节点，而考虑兼容，可以使用 12parentNode.children[ parentNode.children.length - 1 ]//取所有子元素节点集合的长度-1，即为最后一个元素序号 兄弟节点 1node.nextSibling nextSibling 返回当前元素下一个兄弟节点，找不到返回null，包含所有节点 1node.previousSibling previousSibling 返回当前元素上一个兄弟节点，找不到返回nill，包含所有节点 1node.nextElementSibling nextElementSibling 返回当前元素下一个兄弟元素节点，找不到返回null 1node.previousElementSibling previousElementSibling 返回当前元素上一个兄弟元素节点，找不到返回null 注意：(3)(4)有兼容性问题，IE9 以上支持 解决方案： 自己封装一个函数： 123456789function getNextElementSibling(element) &#123; var el = element; while (el = el.nextSibling)&#123; if (el.nodeType == 1)&#123; return el; &#125; &#125; return null;&#125; 创建节点1document.createElement('tagName') document.createElement()方法创建由tagName指定的HTML元素，因为这些元素原本不存在，而是根据需求动态生成的，所以也成为动态创建元素节点 添加节点 node.appendChild(child) &lt;!--￼16--&gt; ​ node.insertBefore() 方法将一个节点添加到父节点的指定子节点**前面**，类似CSS中的before伪元素 删除节点1node.removeChild(child) node.removeChild() 方法从DOM中删除一个子节点，返回删除的节点 复制节点（克隆节点）1node.cloneNode() node.cloneNode() 方法返回调用该方法的节点的一个副本 注意： 如果括号参数为空或者flase，是浅拷贝，只克隆复制节点本身，不克隆里面的子节点 如果括号参数为true，是深度拷贝，会复制节点本身以及里面所有的子节点 三种动态创建元素区别 document. write( ) 12document.write('&lt;div&gt;123&lt;/div&gt;');// 创建div标签 ** element.innerHTML 123var inner = document.querySelector('.inner');inner.innerHTML = '&lt;a href=\"javascript:;\"&gt;删除&lt;/a&gt;'// 创建a标签 document.createElement( ) 1234var create = document.querySelector('.create');var a = document.createElement('a');create.appendChild(a);// 创建a标签 ** 区别： document. write( )是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘 innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘 innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结果稍微复杂 createElement( ) 创建多个元素效率稍微低一点点， 但是结果更清晰","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"4-操作元素2","slug":"4-操作元素2","date":"2020-07-16T01:01:11.000Z","updated":"2020-07-16T07:12:52.299Z","comments":true,"path":"2020/07/16/4-操作元素2/","link":"","permalink":"http://yoursite.com/2020/07/16/4-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A02/","excerpt":"操作元素排他思想如果有同一组元素，想要某一元素实现某种样式，需要用到循环的排他思想算法： 所有元素全部清除样式 给当前元素设置样式 注意顺序不能颠倒（一般设置两层循环）","text":"操作元素排他思想如果有同一组元素，想要某一元素实现某种样式，需要用到循环的排他思想算法： 所有元素全部清除样式 给当前元素设置样式 注意顺序不能颠倒（一般设置两层循环） 自定义属性的操作获取属性值 element.属性 ===》 获取内置属性值（元素本身自带的属性） element.getAttribute(‘属性’) ===》主要获得自定义的属性 设置属性值 element.属性 = ‘值’ ===》设置内置属性值 element.setAttribute(‘属性’, ‘值’) ===》主要针对自定义属性 更改属性 div.className = ‘navs’ ===》将div的class类名改为navs div.setAttribute(‘class’, ‘footer’) ===》将div的class类名改为footer 注意：两个的类名要求不同，一个是className，一个是class 移除属性 element.removeAttribute(‘属性’) H5自定义属性自定义属性目的：是为了保存并使用数据，有些数据可以保存到页面中而不用保存到数据库 自定义属性获取通过 getAttribute(“属性”) 方法 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性 H5新增了自定义属性 设置H5自定义属性H5规定自定义属性data-开头作为属性名并且赋值 1&lt;div data-index=\"1\"&gt;&lt;/div&gt; 或者使用JS设置自定义属性 1element.setAttribute('data-index' , 2); 获取H5自定义属性 兼容性获取：element.getAttribute( ‘data-index’ ); H5新增 element.dataset.index 或者 element.dataset[ ‘index’ ] 新增只有IE 11以上支持 注意： 如果自定义属性里面有多个 - 链接的单词，用(2)获取的时候采取驼峰命名法 1&lt;div data-list-name=\"andy\"&gt;&lt;/div&gt; 12console.log(div.dataset.listName);console.log(div.dataset[ 'listName' ]);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"错误示警！！！","slug":"3-错误示警！！！","date":"2020-07-15T15:39:02.000Z","updated":"2020-07-15T15:48:32.222Z","comments":true,"path":"2020/07/15/3-错误示警！！！/","link":"","permalink":"http://yoursite.com/2020/07/15/3-%E9%94%99%E8%AF%AF%E7%A4%BA%E8%AD%A6%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"警告并警惕以下是曾经犯过的错，当时花了很长时间解决，让人心烦意乱，警惕不要再犯！！","text":"警告并警惕以下是曾经犯过的错，当时花了很长时间解决，让人心烦意乱，警惕不要再犯！！ JavaScript在获取元素时 警惕获取的是单一变量还是伪数组，伪数组使用时要带上序号，否则无法设置事件 以下是常见的获取得到伪数组的方法： *getElementsByTagName()方法 * 根据标签获取 getElementsByClassName(“类名”) 根据类名获取 querySelectorAll(“选择器”) 根据选择器获取所有 警惕在元素操作时使用的是接口方法还是赋值： alert（“文本”） console. log（“文本”） 《下面的不一样！！》 div.innerText = ‘文本’ 赋值改变文本内容 div.innerHTML = ‘文本’ 赋值改变，而且！HTML是全大写 持续更新————————","categories":[{"name":"扩展知识","slug":"扩展知识","permalink":"http://yoursite.com/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"曾经犯的错误","slug":"曾经犯的错误","permalink":"http://yoursite.com/tags/%E6%9B%BE%E7%BB%8F%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"}]},{"title":"今日无话","slug":"今日无话","date":"2020-07-15T13:16:11.000Z","updated":"2020-07-15T13:18:30.739Z","comments":true,"path":"2020/07/15/今日无话/","link":"","permalink":"http://yoursite.com/2020/07/15/%E4%BB%8A%E6%97%A5%E6%97%A0%E8%AF%9D/","excerpt":"","text":"七月十五日 小晴很热​ 今日下午游泳，晚上踩单车 ​ 很累 ​ 无话 ​ 进度0 ​ ……淦","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"无题","slug":"无题","permalink":"http://yoursite.com/tags/%E6%97%A0%E9%A2%98/"}]},{"title":"不知名胡话-其二","slug":"不知名胡话-其二","date":"2020-07-14T12:40:49.000Z","updated":"2020-07-15T13:18:52.925Z","comments":true,"path":"2020/07/14/不知名胡话-其二/","link":"","permalink":"http://yoursite.com/2020/07/14/%E4%B8%8D%E7%9F%A5%E5%90%8D%E8%83%A1%E8%AF%9D-%E5%85%B6%E4%BA%8C/","excerpt":"","text":"七月十四日 大晴​ 今天是去健身房的第二天。 ​ 说是第二天，也可以说是第三天，昨天去游泳了，前天去跑步，今天是去上免费的私教课。 ​ 累是肯定累的，我胳膊和胸大肌现在还疼着呢。小时候猛地站起来时会头晕，现在已经很少遇到了，可是今天在甩包的时候还是晕了，而且晕的厉害……不过感觉甩绳还挺轻松的，看《西红市首富》的时候有个镜头就是甩绳，一直没试过，今天有幸试了下，可惜是私教课的内容，以后估计碰不到了吧。 ​ 说到以后，之前看到半佛仙人的视频，说健身房跑路的。哎西吧，我前天交的钱，他当天晚上发视频。不过，如果能在这个健身房跑路前把身材练好那还是挺值得的。 ​ 其实今天累到不行，还好是早上看了DOM的几个视频，不然今天的进度又是0了。 ​ 早点学完Javascript和Vue，去找工作吧，不然连告白的勇气都没有（尴尬","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"胡话笔记","slug":"胡话笔记","permalink":"http://yoursite.com/tags/%E8%83%A1%E8%AF%9D%E7%AC%94%E8%AE%B0/"}]},{"title":"4-操作元素","slug":"4-操作元素1","date":"2020-07-14T08:48:52.000Z","updated":"2020-07-14T13:54:50.551Z","comments":true,"path":"2020/07/14/4-操作元素1/","link":"","permalink":"http://yoursite.com/2020/07/14/4-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A01/","excerpt":"操作元素改变元素内容element.innerText 从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉 123btn.onclick = function()&#123; div.innerText = '2019-6-6' ** 改变div的内容&#125;","text":"操作元素改变元素内容element.innerText 从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉 123btn.onclick = function()&#123; div.innerText = '2019-6-6' ** 改变div的内容&#125; element.innerHTML 起始位置到终止位置的全部内容，包括html，同时保留空格和换行 innerText和innerHTML的区别： innerText不识别html标签，读写时去除空格和换行、标签 innerHTML识别html标签，读写时保留空格和换行、标签（推荐） 常用元素的属性操作案例：点击按钮更换图片 123&lt;button id='ldh'&gt;刘德华&lt;/button&gt;&lt;button id='zxy'&gt;张学友&lt;/button&gt;&lt;img src='images/ldh.jpg' alt='' title='刘德华'&gt; 123456789101112var ldh = document.getElementById('ldg');var zxy = document.getElementById('zxy');var img = document.querySelector('img');zxy.onclick = function()&#123; img.src = 'images/zxy.jpg'; ** 修改图片路径属性 img.title = '张学友'; ** 修改图片提示信息属性&#125;ldh.onclick = function()&#123; img.src = 'images/ldh.jpg'; img.title = '刘德华';&#125; 表单元素的属性操作案例：仿京东显示密码——点击按钮将密码框切换为文本框，可以查看明文密码 核心思路：点击按钮，把密码框类型改为文本框 一个按钮两个状态，点击一次，切换为文本框，再点一次切换问密码框 算法：利用一个flag变量，判断flag的值，如果是1就切换为文本框并设置flag为0，如果是0，切换为密码框并设置flag为1 123456&lt;div&gt; &lt;label for=\"\"&gt; &lt;img src=\"images/close.png\" ale=\"\" id=\"eye\"&gt; &lt;/label&gt; &lt;input type=\"password\" name=\"\" id=\"pwd\"&gt;&lt;/div&gt; 123456789101112131415161718.box &#123; position: relative; width: 400px; border-bottom: 1px solid red; margin: 100px auto;&#125;.box input&#123; width: 370px; height: 30px; border: 0; outline: none;&#125;.box img &#123; position: absolute; top: 2px; right: 2px; width: 24px;&#125; 123456789101112131415var eye = document.getElementById('eye');var pwd = document.getElementById('pwd');var flag = 0;eye.onclick = function()&#123; if( flag == 0 )&#123; ** 判断flag的值 pwd.type = 'text'; eye.src='images/open.png'; ** 更换打开眼睛图片 flag = 1; &#125;else&#123; pwd.type = 'password'; eye.src='images/close.png'; ** 更换闭上眼睛图片 flag = 0; &#125;&#125; 样式属性操作element.style 行内样式操作12345678var test = document.querySelector('div');test.onclick = function()&#123; this.style.backgroundColor = 'purple'; this.style.color = '#fff'; this.style.fontSize = '25px'; this.style.marginTop = '100px';&#125; 注意： JS里的样式采取驼峰命名法，比如 fontSize、backgroundColor JS修改style样式操作，产生的是行内样式，CSS权重比较高 案例：仿淘宝关闭二维码 核心思路：利用样式的显示和隐藏，display: none隐藏元素，display: block显示元素 点击按钮，就让这个二维码盒子隐藏起来 12345&lt;div class=\"box\"&gt; 淘宝二维码 &lt;img src=\"images/tao.png\" alt=\"\"&gt; &lt;i class=\"close-btn\"&gt;×&lt;/i&gt;&lt;/div&gt; 123456789101112131415.box img &#123; width: 60px; margin-top: 5px;&#125;.close-btn &#123; position: absolute; top: -1px; left: -16px; width: 14px; height: 14px; border: 1px solid #ccc; line-height: 14px; font-family: Arial, Helvetica, sans-serif; cursor: pointer;&#125; 123456var btn = document.querySelector('.close-btn');var box = document.querySelector('.box');btn.onclick = function()&#123; box.style.display = 'none';&#125; element.className 类名样式操作123&lt;div&gt; 文本&lt;/div&gt; 123456.change &#123; background-color: purple; color: #fff; font-size: 25px; margin=top: 100px;&#125; 123456var test = document.querySelector('div');test.onclick = function()&#123; this.className = 'change'; // 将当前元素的类名改为change，即预先在css文件中定义的样式&#125; 注意： 如果样式修改较多，可以采取操作类名方式更改元素样式 class因为是保留字，因此使用className来操作元素类名属性 className会直接更改元素的类名，覆盖原先的类名 如果想保留原先的类名，可以赋值两个类名，中间用空格隔开 12 this.className = 'first change';// first是原先的类名，覆盖之后则为多类名选择器","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"3-事件基础","slug":"3-事件基础","date":"2020-07-14T07:44:30.000Z","updated":"2020-07-14T08:48:32.843Z","comments":true,"path":"2020/07/14/3-事件基础/","link":"","permalink":"http://yoursite.com/2020/07/14/3-%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"事件基础事件是可以被JS侦测到的行为 事件三要素： 事件源——事件被触发的对象 事件类型——如何触发/什么事件 事件处理程序——通过一个函数赋值的方式","text":"事件基础事件是可以被JS侦测到的行为 事件三要素： 事件源——事件被触发的对象 事件类型——如何触发/什么事件 事件处理程序——通过一个函数赋值的方式 1&lt;button id=\"btn\"&gt;按钮&lt;/button&gt; 123456var btn = document.getElementById(\"btn\");** 获取元素id **btn.onclick = function()&#123; alert(\"输出\");&#125;** 通过事件三要素处理事件 ** 常见的鼠标事件 鼠标事件 触发条件 onclick 鼠标点击左键 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动 onmouseup 鼠标弹起 onmousedown 鼠标按下","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"2-DOM","slug":"2-获取元素","date":"2020-07-14T02:52:12.000Z","updated":"2020-07-14T07:43:10.790Z","comments":true,"path":"2020/07/14/2-获取元素/","link":"","permalink":"http://yoursite.com/2020/07/14/2-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0/","excerpt":"DOM——获取元素文档对象模型（DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口 可以改变网页内容、结果、样式 DOM树 文档：一个页面就是一个文档，DOM中使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点：网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示","text":"DOM——获取元素文档对象模型（DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口 可以改变网页内容、结果、样式 DOM树 文档：一个页面就是一个文档，DOM中使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点：网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 获取元素根据ID获取使用getElementById(id)方法 1var element = document.getElementById(‘id’); 参数： element是一个Element对象，如果当前文档中拥有特点ID的元素不存在，则返回null id是大小写敏感的字符串，代表了所要查找的元素的唯一ID 返回值： 返回一个匹配到ID的DOM Element对象，若当前Document没有找到，则返回null 根据标签名获取使用getElementsByTagName()方法返回带有指定标签名的对象的集合 1var list = document.getElementsByTagName('li') 返回的是 获取元素对象的集合 以伪数组的形式存储 注意： 因为得到的是一个对象的集合，所以想要操作里面的元素就需要遍历 得到的元素是动态的 如果页面中只有一个该标签名，返回的还是伪数组形式 如果页面中没有这个元素，返回的是空的伪数组 还可以获取某个元素（父元素）内部所有指定标签名的子元素 12345element.getElementsByTagName('标签名');&lt;!-- 例子 --&gt;var ol_list = document.getElementsByTagName('ol');console.log(ol_list[0].getElementsByTagName('li'));** 必须指明是哪个父元素 而不能是伪数组形式 ** 注意：父元素必须是单个元素（必须指明是哪个元素对象），获取的时候不包括父元素子级 HTML5新增的方法 根据类名获取 12var boxs = document.getElementsByClassName(\"类名\");** 返回的是一个伪数组的集合 ** 根据指定选择器获取一个对象 12345var firstBox = document.querySelector(\"选择器\");** 返回的是第一个元素对象 **** 切记 里面的选择器需要加符号 .box #nav **var firstBox = document.querySelector(\"#nav\"); 根据指定选择器获取所有对象 12 var allBox = document.querySelectorAll(\"选择器\");** 返回指定选择器的所有元素对象集合 伪数组 ** 获取特定元素获取body123var bodyEle = document.body;console.log(bodyEle);console.dir(bodyEle); 获取HTML12var hrmlEle = document.documentElement;console.log(htmlEle);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"1-Web_APIs","slug":"1-Web-APIs","date":"2020-07-14T02:32:37.000Z","updated":"2020-07-14T03:03:38.468Z","comments":true,"path":"2020/07/14/1-Web-APIs/","link":"","permalink":"http://yoursite.com/2020/07/14/1-Web-APIs/","excerpt":"","text":"Web_APIsAPIAPI(应用程序编程接口) 是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问的一组例程的能力，而又无需访问源码或理解内部工作机制的细节。 Web APIWeb API是浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM） MDN详细API：https://developer.mozilla.org/zh-CN/docs/Web/API","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"APIs","slug":"APIs","permalink":"http://yoursite.com/tags/APIs/"}]},{"title":"1-Logo的SEO优化","slug":"1-Logo的SEO优化","date":"2020-07-12T13:11:44.000Z","updated":"2020-07-12T13:18:06.057Z","comments":true,"path":"2020/07/12/1-Logo的SEO优化/","link":"","permalink":"http://yoursite.com/2020/07/12/1-Logo%E7%9A%84SEO%E4%BC%98%E5%8C%96/","excerpt":"","text":"LOGO SEO 优化为了配合搜索引擎的喜好，对LOGO进行设计时应当遵循操作： logo里首先放一个h1标签，目的是为了提权，告诉搜索引擎这里很重要 h1里面再放一个链接，可以返回首页，把logo的背景图片给链接即可 为了搜索引擎收录网页，链接里要放文字（网站名称），但是文字不要显示出来 方法1：text-indent移到盒子外面（text-indent: -9999px)，然后*overflow: hidden; *——淘宝做法 方法2：直接给font-size: 0;，就看不到文字了——京东做法 最后给链接一个title属性，鼠标放在logo上可以看到提示文字","categories":[{"name":"扩展知识","slug":"扩展知识","permalink":"http://yoursite.com/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"布局页面","slug":"布局页面","permalink":"http://yoursite.com/tags/%E5%B8%83%E5%B1%80%E9%A1%B5%E9%9D%A2/"}]},{"title":"16-HTML5提高1","slug":"16-HTML5提高","date":"2020-07-11T13:14:33.000Z","updated":"2020-07-23T02:53:56.826Z","comments":true,"path":"2020/07/11/16-HTML5提高/","link":"","permalink":"http://yoursite.com/2020/07/11/16-HTML5%E6%8F%90%E9%AB%98/","excerpt":"HTML5提高HTML5的新增特性主要针对以前的不足，增加了一些新的标签、新的表单和新的表单属性 这些新特性都有兼容问题，基本IE9+以上版本才支持，如果不考虑兼容性问题，可以大量使用这些特性","text":"HTML5提高HTML5的新增特性主要针对以前的不足，增加了一些新的标签、新的表单和新的表单属性 这些新特性都有兼容问题，基本IE9+以上版本才支持，如果不考虑兼容性问题，可以大量使用这些特性 HTML5新增的语义化标签 &lt;header&gt;：头部标签 &lt;nav&gt;：导航标签 &lt;article&gt;：内容标签 &lt;section&gt;：定义文档某个区域 &lt;aside&gt;：侧边栏标签 &lt;footer&gt;：尾部标签 注意： 这种语义化标准主要是针对搜索引擎 这些新标签页面中可以多次使用 在IE9中，需要把这些元素转换为块级元素 移动端更常用这些标签 HTML5新增的多媒体标签使用它们可以很方便的在页面中嵌入音频和视频，而不用使用flash和其他浏览器插件 音频：&lt;audio&gt; 视频：&lt;video&gt; 视频&lt;video&gt;当前&lt;video&gt;元素支持三种视频格式，尽量使用mp4格式 浏览器 MP4 WebM Ogg IE YES NO NO Chrome YES YES YES Firefox YES YES YES Safari YES NO NO Opera YES YES YES 语法：1&lt;video src=\"文件地址\" controls=\"controls\"&gt;&lt;/video&gt; 常见属性 属性 值 描述 autoplay autoplay 视频就绪自动播放Chrome需要添加muted来解决自动播放问题 controls controls 向用户显示播放控件 width 像素 设置播放器宽度 height 像素 设置播放器高度 loop loop 播放完是否继续播放该视频，循环播放 preload auto（预先加载视频）none（不应加载视频） 规定是否预加载视频如果有了autoplay 就忽略该属性 src URL 视频URL地址 poster ImgURL 加载等待的画面图片 muted muted 静音播放 音频&lt;audio&gt;当前&lt;audio&gt;元素支持三种音频格式： 浏览器 MP3 Wav Ogg IE YES NO NO Chrome YES YES YES Firefox YES YES YES Safari YES YES NO Opera YES YES YES 语法1&lt;audio src=\"文件地址\" controls=\"controls\"&gt;&lt;/audio&gt; 常见属性 属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放 controls controls 向用户显示控件 loop loop 每当音频结束时重新开始播放 src URL 要播放的URL 谷歌浏览器把音频和视频自动播放禁止了 HTML5新增的input表单在input标签中，type属性新增了许多表单类型 属性值 说明 type=”email” 限制用户输入必须为Email类型 type=”url” 限制用户输入必须为URL类型 type=”date” 限制用户输入必须为日期类型 type=”time” 限制用户输入必须为时间类型 type=”month” 限制用户输入必须为月类型 type=”week” 限制用户输入必须为周类型 type=”number” 限制用户输入必须为数字类型 type=”tel” 手机号码 type=”search” 搜索框 type=”color” 生成一个颜色选择表单 HTML5新增的表单属性 属性 值 说明 required required 表单拥有该属性表示其内容不能为空，必填 placeholder 提示文本 表单的提示信息，存在默认值将不显示 autofocus autofocus 自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplete off / on 当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选择默认已经打开，如 autocomplete=”auto”关闭autocomplete=”off”需要放在表单内，同时加上name属性，同时成功提交 multiple multiple 可以多选文件提交，通常和文件域搭配 type=”file”","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"15-CSS初始化","slug":"15-CSS初始化","date":"2020-07-11T12:07:29.000Z","updated":"2020-07-11T13:11:04.682Z","comments":true,"path":"2020/07/11/15-CSS初始化/","link":"","permalink":"http://yoursite.com/2020/07/11/15-CSS%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"CSS初始化不同浏览器对有些标签的默认值不同，为了消除不同浏览器对HTML文本呈现的差异，照顾兼容性，需要对CSS初始化 重设浏览器样式（CSS reset） 每个网页都必须首先进行CSS初始化 Unicode编码字体：把中文字体的名称用相应的Unicode编码代替，这样可以有效避免浏览器解释CSS代码时候出现乱码问题 比如： 黑体 \\9ED1\\4F53 宋体 \\5B8B\\4F53 微软雅黑 \\5FAE\\8F6F\\96C5\\9ED1","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"14-常见布局技巧","slug":"14-常见布局技巧","date":"2020-07-11T11:47:52.000Z","updated":"2020-07-22T13:57:07.081Z","comments":true,"path":"2020/07/11/14-常见布局技巧/","link":"","permalink":"http://yoursite.com/2020/07/11/14-%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7/","excerpt":"常见布局技巧margin负值运用浮动布局时利用 margin-left: 1px; 实现边框的重叠 让每个盒子margin往左移动-1px正好压住相邻盒子边框 鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有定位，则加相对定位【保留位置】，如果有定位，则加z-index）","text":"常见布局技巧margin负值运用浮动布局时利用 margin-left: 1px; 实现边框的重叠 让每个盒子margin往左移动-1px正好压住相邻盒子边框 鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有定位，则加相对定位【保留位置】，如果有定位，则加z-index） 文字围绕浮动元素将图片和文字放在同一个div中后，图片设置为float，则文字会自动围绕图片排布——原本float的作用就是做文字围绕的效果的 行内块元素的运用原本是行内元素，display为行内块后可以设置宽高、并且相互之间有空隙 CSS三角强化制作直角不等腰三角形： 思路：将下面的border去掉后，上面的border变大，即可得到 12345678.box &#123; width: 0; height: 0; border-top: 100px solid pink; border-right: 50px solid skyblue; border-bottom: 0 solid blue; border-left: 50px solid green;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"13-溢出的文字省略号显示","slug":"13-溢出的文字省略号显示","date":"2020-07-11T11:34:42.000Z","updated":"2020-07-11T11:47:24.353Z","comments":true,"path":"2020/07/11/13-溢出的文字省略号显示/","link":"","permalink":"http://yoursite.com/2020/07/11/13-%E6%BA%A2%E5%87%BA%E7%9A%84%E6%96%87%E5%AD%97%E7%9C%81%E7%95%A5%E5%8F%B7%E6%98%BE%E7%A4%BA/","excerpt":"溢出的文字省略号显示单行文本溢出显示省略号必须满足三个条件： 先强制一行内显示文本 white-space: nowrap; (默认normal自动换行) 超出部分隐藏 overflow: hidden; 文字用省略号替代超出部分 text-overflow: ellipsis;","text":"溢出的文字省略号显示单行文本溢出显示省略号必须满足三个条件： 先强制一行内显示文本 white-space: nowrap; (默认normal自动换行) 超出部分隐藏 overflow: hidden; 文字用省略号替代超出部分 text-overflow: ellipsis; 多行文本溢出显示省略号有较大兼容性问题，适合于webKit浏览器或移动到 12345678overflow: hidden;text-overflow: ellipsis;/* 弹性伸缩盒子模型显示 */display: -webkit-box;/* 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 更推荐让后台来做这个效果，可以设置显示多少字，操作简单","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"12-Vertical-align属性应用","slug":"12-Vertical-align属性应用","date":"2020-07-11T11:04:23.000Z","updated":"2020-07-22T13:40:30.340Z","comments":true,"path":"2020/07/11/12-Vertical-align属性应用/","link":"","permalink":"http://yoursite.com/2020/07/11/12-Vertical-align%E5%B1%9E%E6%80%A7%E5%BA%94%E7%94%A8/","excerpt":"vertical-align属性应用实现行内块元素和文字垂直对齐经常用于设置图片或者表单（行内块元素）和文字垂直对齐","text":"vertical-align属性应用实现行内块元素和文字垂直对齐经常用于设置图片或者表单（行内块元素）和文字垂直对齐 只针对行内元素或者行内块元素有效 1vertical-align: baseline; 值 描述 baseline 默认，元素放置在父元素的基线上 top 把元素的顶端与行中最高元素的顶端对齐 middle 把此元素放置在父元素的中部 bottom 把元素的顶部与行中最低元素的顶端对齐 解决图片底部默认空白缝隙问题bug：图片底部会有一个空白缝隙，原因是行内块元素会和文字的基线对齐 两种解决方法： 给图片添加vertical-align: middle | top | bottom等（推荐） 把图片转换为块级元素*display: block; *","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"11-CSS用户界面样式","slug":"11-CSS用户界面样式","date":"2020-07-11T10:55:14.000Z","updated":"2020-07-11T11:03:29.754Z","comments":true,"path":"2020/07/11/11-CSS用户界面样式/","link":"","permalink":"http://yoursite.com/2020/07/11/11-CSS%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F/","excerpt":"CSS用户界面样式界面样式，更改一些用户操作样式，提高更换的用户体验","text":"CSS用户界面样式界面样式，更改一些用户操作样式，提高更换的用户体验 鼠标样式cursor1li &#123; cursor: pointer; &#125; 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 轮廓线给表单添加 outline: 0; 或者 outline: none; 样式后，可以去掉默认的蓝色边框 防止拖拽文本域 resize实际开发中，文本域右下角不可以拖拽 1textarea &#123; resize: none; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"10-CSS三角","slug":"10-CSS三角","date":"2020-07-11T10:37:09.000Z","updated":"2020-07-11T10:54:50.541Z","comments":true,"path":"2020/07/11/10-CSS三角/","link":"","permalink":"http://yoursite.com/2020/07/11/10-CSS%E4%B8%89%E8%A7%92/","excerpt":"","text":"CSS三角网页中常见的一些三角形，使用CSS直接画出来 123456789div &#123; width: 0; **宽、高必须是0 height: 0; line-height: 0; **行高和字体大小是为了照顾低版本浏览器 font-size: 0; border: 50px solid transparent; **将四个边改为透明色 border-left-color: pink; **将左边框改为粉色 **三角向右&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"9-字体图标","slug":"9-字体图标","date":"2020-07-11T10:01:02.000Z","updated":"2020-07-11T10:36:51.801Z","comments":true,"path":"2020/07/11/9-字体图标/","link":"","permalink":"http://yoursite.com/2020/07/11/9-%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/","excerpt":"字体图标为了解决精灵图的缺点： 图片文件较大 图片本身放大会失真 图片制作完毕后更换非常复杂 字体图标展示的是图标，本质属于字体","text":"字体图标为了解决精灵图的缺点： 图片文件较大 图片本身放大会失真 图片制作完毕后更换非常复杂 字体图标展示的是图标，本质属于字体 优点： 轻量级 灵活性 兼容性 字体图标的下载推荐下载网站： icomoon字库 http://icomoon.io/ 阿里 iconfont字库 http://www.iconfont.cn/ 字体图标的引入下载完毕之后，源文件不要删，后面会用 把下载包里面的fonts文件夹放入页面根目录下 在CSS样式中全局声明字体 123456789101112131415&lt;style&gt; @font-face &#123; font-family: 'icomoon'; src: url('fonts/icomoon.eot?mcjlk6'); src: url('fonts/icomoon.eot?mcjlk6#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?mcjlk6') format('truetype'), url('fonts/icomoon.woff?mcjlk6') format('woff'), url('fonts/icomoon.svg?mcjlk6#icomoon') format('svg'); font-weight: normal; font-style: normal; font-display: block;&#125; &lt;/style&gt; 在下载包中的.css文件中复制即可 打开下载包中的Demo.html文件，找到需要的字体图标，复制后面的小框框到网页中的需要位置 1&lt;span&gt;&lt;/span&gt; 在CSS中，该字体图标所属标签中设置字体样式为2中代码的字体家族 123span &#123; font-family: 'icomoon';&#125; 字体图标的追加添加新的字体图标到原先的字体文件中 把压缩包里的selection.json重新上传，然后选中新图标，重新下载压缩包，并替换原来的文件即可","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"8-精灵图","slug":"8-精灵图","date":"2020-07-11T08:29:22.000Z","updated":"2020-07-11T10:00:09.218Z","comments":true,"path":"2020/07/11/8-精灵图/","link":"","permalink":"http://yoursite.com/2020/07/11/8-%E7%B2%BE%E7%81%B5%E5%9B%BE/","excerpt":"精灵图为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度 精灵技术主要针对于背景图片使用，就是把多个小背景图片整合到一张大图片中 移动背景图片位置，此时可以用background-position 移动的距离就是这个目标图片的x和y坐标 因为一般情况下都是往上或往左移动，所以数值是负值 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置","text":"精灵图为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度 精灵技术主要针对于背景图片使用，就是把多个小背景图片整合到一张大图片中 移动背景图片位置，此时可以用background-position 移动的距离就是这个目标图片的x和y坐标 因为一般情况下都是往上或往左移动，所以数值是负值 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置 12background-image: url(URL);background-position: X坐标 Y坐标; 12345.p&#123; width: 100px; heigth: 100px; background: url(ab.jpg) no-repeat -493px -285px;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"7-元素的显示与隐藏","slug":"7-元素的显示与隐藏","date":"2020-07-11T06:45:55.000Z","updated":"2020-07-11T10:00:30.237Z","comments":true,"path":"2020/07/11/7-元素的显示与隐藏/","link":"","permalink":"http://yoursite.com/2020/07/11/7-%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/","excerpt":"元素的显示与隐藏让一个元素在页面中隐藏或者显示出来","text":"元素的显示与隐藏让一个元素在页面中隐藏或者显示出来 display属性 display: none; 隐藏对象 display: block; 除了转换为块级元素之外，还有显示元素的意思 display隐藏元素后，不再占有原来的位置 visibility 可见性visibility属性用于指定一个元素应可见还是隐藏 visibility: visible；元素可视 visibility: hidden; 元素隐藏 visibility隐藏元素后，继续占有原先位置 overflow溢出overflow属性指定了如果内容溢出了一个元素的框（超过其指定高度及宽度）时，会发生什么 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 一般情况下，不想让溢出的内容显示出来，因为会影响布局 但是如果有定位的盒子，慎用overflow: hidden; 因为会隐藏多余的部分","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"6-定位","slug":"6-定位","date":"2020-07-10T11:30:24.000Z","updated":"2020-07-11T06:45:20.455Z","comments":true,"path":"2020/07/10/6-定位/","link":"","permalink":"http://yoursite.com/2020/07/10/6-%E5%AE%9A%E4%BD%8D/","excerpt":"定位定位： 将盒子定在某一位置，所以定位也是在摆放盒子 定位=定位模式+边偏移 定位模式用于指定一个元素在文档中的定位方式 边偏移决定了该元素的最终位置","text":"定位定位： 将盒子定在某一位置，所以定位也是在摆放盒子 定位=定位模式+边偏移 定位模式用于指定一个元素在文档中的定位方式 边偏移决定了该元素的最终位置 定位模式定位模式决定元素的定位方式，通过CSS的position属性设置 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 边偏移定位的盒子移动的最终位置，有top、bottom、left、right四个属性 属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom bottom:80px 底部偏移量，定义元素相对于其父元素下边线的距离 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 静态定位元素默认定位方式，无定位的意思 123选择器 &#123; position: static;&#125; 静态定位按照标准流特性摆放位置，没有边偏移 静态定位在布局时很少用到 相对定位（重要）相对于原来的位置移动 123选择器 &#123; position: relative;&#125; 特点： 相对于在自己原本的位置来移动（移动位置的时候参照点是自己原来的位置） 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它（不脱标） 绝对定位 absolute(重要)相对于祖先元素移动位置 1选择器&#123; position：absolute；&#125; 特点： 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document文档） 如果祖先元素有定位（相对、绝对、固定），则以最近一级的有定位的祖先元素为参考点移动位置 绝对定位不再占有原先的位置（脱标） 子绝父相子级是绝对定位的话，父级必须要用相对定位 子级绝对定位，不会占有位置，可以放在父盒子的任何地方，不会影响其他的兄弟盒子 父盒子需要加定位限制子盒子在父盒子内显示 父盒子布局时，需要占有位置，因此父盒子只能是相对定位 所以相对定位经常用来作为绝对定位的父级 固定定位（重要）元素固定在浏览器的可视区位置，浏览器页面滚动时元素位置不会改变 1选择器&#123; position：fixed；&#125; 特点： 以浏览器的可视窗口移动元素 固定定位不占用原先位置（脱标） 固定定位小技巧——定位版心固定在版心右侧位置 算法： 让固定定位的盒子 left: 50%. 走到浏览器可视区（版心）的一半位置 让固定定位的盒子 margin-left: 版心宽度的一般距离。多走版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了 粘性定位可被认为是相对定位和固定定位的混合 1选择器&#123; position：sticky；top：10px；&#125; 特点： 以浏览器窗口为参照点移动元素（固定定位特点） 占有原先位置（相对定位特点） 必须添加top、left、right、bottom其中一个才有效 定位叠放次序使用定位布局时，可能出现盒子重叠的情况，此时可以使用z-index控制盒子的前后次序（Z轴） 1选择器 &#123; z-index：1；&#125; 数值可以是正整数、负整数、0，默认是auto，数值越大，盒子越靠上 如果属性值相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性 定位扩展绝对定位的盒子居中加了绝对定位的盒子不能通过margin: 0 auto;设置水平居中，但是可以通过算法实现水平和垂直居中： 水平居中： left: 50%; 让盒子的左侧移动到父级元素的水平中心位置 margin-left: -100px; 让盒子向左移动自身宽度的一半（负值） 垂直居中： top: 50%; 让盒子的顶部移动到父级元素的水平中心位置 margin-top: -100px; 让盒子向上移动自身宽度的一半（负值） 定位特殊特性绝对定位和固定定位也和浮动类似 行内元素添加绝对或者固定定位，可以直接设置高度和宽度 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标的盒子不会触发外边距塌陷浮动、绝对、固定元素都不会触发外边距合并的问题 浮动与绝对、固定定位的不同绝对、固定定位会完全压住盒子 浮动元素不同，只会压住下面的标准流盒子，但是不会压住下面标准流盒子里面的文字（图片） 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的，文字会围绕浮动元素","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"6-函数","slug":"6-函数","date":"2020-07-10T10:51:44.913Z","updated":"2020-07-10T10:50:09.030Z","comments":true,"path":"2020/07/10/6-函数/","link":"","permalink":"http://yoursite.com/2020/07/10/6-%E5%87%BD%E6%95%B0/","excerpt":"函数声明函数123function 函数名()&#123; //函数体&#125;","text":"函数声明函数123function 函数名()&#123; //函数体&#125; arguments的使用当不确定有多少个参数传递的时候，可以用arguments来获取，在JS中，arguments实际上是当前函数的一个内置对象。所有函数都内置了一个arguments对象，存储了传递的所有实参 arguments展示形式是一个伪数组，因此可以遍历，伪数组特点： 具有length属性 按索引方式储存数据 不具有数组的push，pop等方法 1234567function fn() &#123; for(var i=0; i &lt; arguments.length;i++)&#123; console.log(arguments[i]); &#125;&#125; fn(1,2,3,4,5);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"5-循环","slug":"5-循环","date":"2020-07-10T10:51:43.319Z","updated":"2020-07-10T10:50:18.106Z","comments":true,"path":"2020/07/10/5-循环/","link":"","permalink":"http://yoursite.com/2020/07/10/5-%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"循环断点测试断点调试可以观察程序的运行过程： 浏览器中按F12——》source——》找到需要调试的文件——》在程序某一行设置断点 watch：监视，通过watch可以监视变量的值的变化 F11：程序单步执行，让程序一行一行执行，这时候观察watch中变量值的变化","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"4-流程控制","slug":"4-流程控制","date":"2020-07-10T10:51:41.627Z","updated":"2020-07-10T08:40:33.533Z","comments":true,"path":"2020/07/10/4-流程控制/","link":"","permalink":"http://yoursite.com/2020/07/10/4-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"流程控制基本等同Java，不再赘述","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"3-运算符","slug":"3-运算符","date":"2020-07-10T10:51:26.310Z","updated":"2020-07-10T08:36:02.932Z","comments":true,"path":"2020/07/10/3-运算符/","link":"","permalink":"http://yoursite.com/2020/07/10/3-%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"运算符比较运算符 运算符 说明 == 判等号（会转型） === !== 全等，要求值和数据类型都一致 12console.log(19 == '19'); //trueconsole.log(19 === '19'); //false","text":"运算符比较运算符 运算符 说明 == 判等号（会转型） === !== 全等，要求值和数据类型都一致 12console.log(19 == '19'); //trueconsole.log(19 === '19'); //false 逻辑运算符短路运算（逻辑中断）原理：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再运算右边的表达式的值 逻辑与 &amp;&amp; 语法：表达式1 &amp;&amp; 表达式2 如果第一个表达式值为真，则返回表达式2 如果第一个表达式值为假，则返回表达式1 逻辑或 || 语法：表达式1 || 表达式2 如果第一个表达式值为真，则返回表达式1 如果第一个表达式值为假，则返回表达式2","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"2-变量2","slug":"2-变量2","date":"2020-07-10T10:51:23.914Z","updated":"2020-07-10T08:23:59.746Z","comments":true,"path":"2020/07/10/2-变量2/","link":"","permalink":"http://yoursite.com/2020/07/10/2-%E5%8F%98%E9%87%8F2/","excerpt":"变量数字类型数字型范围JS中数值的最大和最小值： 12alert(Number.MAX_VALUE); //1.79e+308alert(Number.MIN_VALUE); //5e-324","text":"变量数字类型数字型范围JS中数值的最大和最小值： 12alert(Number.MAX_VALUE); //1.79e+308alert(Number.MIN_VALUE); //5e-324 数字型三个特殊值123alert(Infinity); //无穷大alert(-Infinity); //无穷小alert(NaN); //非数值 isNaN()用来判断一个变量是否为非数字的类型，不是数字返回true，是数字返回false 字符串转义符 转义符 解释 \\n 换行符 \\\\ 斜杠\\ \\‘ 单引号 \\“ 双引号 \\t 缩进 \\b 空格 字符串长度通过字符串的length属性可以获取字符串长度 12var strmsg='内容';alert(strmsg.length); 字符串拼接 多个字符串之间可以用+号进行拼接，拼接方式为字符串+任何类型=拼接后的新字符串 拼接前会把与字符串相加的任何类型转成字符串 typeof获取变量类型1console.log(typeof num); 数据类型转换转换成字符串 方式 说明 案例 toString() 转成字符串 var num=1;alert(num.toString()); String()强制转换 转成字符串 var num=1;alert(String(num)); 加号拼接字符串 和字符串拼接的结果都是字符串 var num=1;alert(num+’ ‘); 转成数字型 方式 说明 案例 parseInt(string) 将string转换成整数数值型 parseInt(‘78’) parseFloat(string) 将string转成浮点数 parseFloat(‘9.2’) Number( ) 强制转换 将string转成数值 Number(‘12’) js隐式转换( - * /) 利用算数运算隐式转换为数值 ‘12’ - 0 注意parseInt和parseFloat的大小写 转换成布尔型 方式 说明 案例 Boolean() 将其他类型转成布尔值 Boolean(‘true’); 代表空、否定的值会被转换成false，如’’、0、NaN、null、undefined 其余值都会转成true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"2-变量1","slug":"2-变量1","date":"2020-07-10T10:51:21.485Z","updated":"2020-07-10T07:49:23.588Z","comments":true,"path":"2020/07/10/2-变量1/","link":"","permalink":"http://yoursite.com/2020/07/10/2-%E5%8F%98%E9%87%8F1/","excerpt":"变量声明变量1var age; //声明一个名称为age的变量 var是JS关键字，用来声明变量","text":"变量声明变量1var age; //声明一个名称为age的变量 var是JS关键字，用来声明变量 赋值1age = 10; //给age变量赋值10 输出结果1console.log(age); //向控制台输出变量 变量的初始化1var name = '我是谁'; //声明变量同时赋值字符串 输入并存储变量12var name = prompt('请输入你的名字');alert(name); //弹出含变量内容的提示框 语法扩展同时声明多个变量只需要写一个var，多个变量之间用英文逗号隔开 1var age = 10, name = 'zx', sex = 'man' 声明变量特殊情况 情况 说明 结果 var age; consloe.log(age) 只声明 不赋值 undefined consloe.log(age) 不声明 不赋值 报错 age=10；console.log(age); 不声明 只赋值 10 变量命名规范 由字母、数字、下划线、美元符号组成 严格区分大小写 不能以数字开头 不能是关键字、保留字 变量名必须有意义 遵守驼峰命名法，首字母小写，后面单词的首字母大写","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"1-初识JavaScript","slug":"1-初识JavaScript","date":"2020-07-10T10:51:17.180Z","updated":"2020-07-10T07:32:32.966Z","comments":true,"path":"2020/07/10/1-初识JavaScript/","link":"","permalink":"http://yoursite.com/2020/07/10/1-%E5%88%9D%E8%AF%86JavaScript/","excerpt":"初识JavaScript JavaScript是一种运行在客户端的脚本语言 脚本语言：不需要编译，运行过程中由js解释器逐行进行解释并执行 现在也可以基于Node.js技术进行服务器端编程","text":"初识JavaScript JavaScript是一种运行在客户端的脚本语言 脚本语言：不需要编译，运行过程中由js解释器逐行进行解释并执行 现在也可以基于Node.js技术进行服务器端编程 作用 表单动态校验（密码强度检测） 网页特效 服务端开发（Node.js） 桌面程序 App 控制硬件 游戏开发 JS组成 ECMAScript JS语法 DOM 页面文档对象模型 BOM 浏览器对象模型 JS书写位置 行内式，直接写在元素内部 1&lt;input type=\"button\" onclick=\"alert('hello')\" /&gt; 可以将单行或少量JS代码写在HTML标签的时间属性中（以on开头的属性），如：onclick 注意单双引号的使用，在HTML中推荐使用双引号，JS中推荐使用单引号 可读性差 引号易错 特殊情况使用 内嵌式 123&lt;script&gt; alert(\"内容\");&lt;/script&gt; 可以将多行JS代码写在《script》标签中 引用式，外部创建.js文件 12&lt;script src='my.js'&gt;&lt;/script&gt;** script是双标签 利用HTML页面代码结构化，把大段JS独立到页面外，美观 引用外部JS文件的script标签中间不可以写代码 JS输入输出语句 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"5-浮动1","slug":"5-浮动1","date":"2020-07-10T10:51:11.104Z","updated":"2020-07-10T07:31:07.942Z","comments":true,"path":"2020/07/10/5-浮动1/","link":"","permalink":"http://yoursite.com/2020/07/10/5-%E6%B5%AE%E5%8A%A81/","excerpt":"浮动float属性用于创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 123选择器 &#123; float: 属性值;&#125;","text":"浮动float属性用于创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘 123选择器 &#123; float: 属性值;&#125; 属性值 描述 none 元素不浮动（默认） left 元素向左浮动 right 元素向右浮动 浮动特性 浮动元素会脱离标准流（脱标） 浮动元素会一行内显示并且元素顶部对齐 浮动的元素会具有行内块元素的特性 脱标设置了浮动的元素最重要的特性： 脱离标准普通流的控制移动到指定位置 浮动的盒子不再保留原先位置 行显示如果多个盒子设置了浮动，则它们会按照属性值一行内显示并且顶部对齐 注意：浮动的元素是互相贴靠在一起的（没有空隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐 浮动的元素具有行内块特性任何元素都可以浮动，不管原先是什么模式的元素，添加浮动之后，都具有行内块元素相似特性 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动之后，它的大小根据内容决定 浮动的盒子中间没有缝隙 行内元素同理 浮动元素常和标准流父级搭配为了约束浮动元素位置，先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置 浮动布局注意点 浮动元素常和标准流父级搭配 一个元素浮动了，理论上其余的兄弟元素也要浮动 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流 清除浮动为什么需要清除浮动由于父级盒子很多情况下不方便给高度（不明确内容多少），但是子盒子浮动不占位置，最后父级盒子高度为0时，就会影响下面的标准流盒子——在子盒子下面的空间显示 123选择器 &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动影响） right 不允许右侧有浮动元素（清除右侧浮动影响） both 同时清除左右侧浮动的影响 实际工作中，几乎只用clear: both; 清除浮动的策略：闭合浮动 清除浮动的方法 额外标签法（隔墙法），W3C推荐 父级添加overflow属性 父级添加after伪元素 父级添加双伪元素 额外标签法在浮动元素末尾添加一个空的标签，例如《div style=”clear: both”》《/div》 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化较差 注意：要求这个新的空标签必须是块级元素 父级添加overflow给父级添加overflow属性，将其属性值设置为hidden、auto或scroll 注意是给父元素添加代码 优点：代码简洁 缺点：无法显示溢出的部分 ：after伪元素法:after方式是额外标签法的升级版，也是给父元素添加 12345678910.clearfix: after &#123; content: \"\"; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; *zoom: 1;&#125; 双伪元素法也是给父元素添加 12345678910.clearfix: before, .clearfix: after &#123; content: \"\" display: table;&#125;.clearfix: after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码更简洁 缺点：照顾低版本浏览器","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"4-盒子模型2","slug":"4-盒子模型2","date":"2020-07-10T10:51:06.988Z","updated":"2020-07-10T07:31:29.722Z","comments":true,"path":"2020/07/10/4-盒子模型2/","link":"","permalink":"http://yoursite.com/2020/07/10/4-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B2/","excerpt":"盒子模型圆角边框在CSS3中，新增了圆角边框样式，使盒子可以变成圆角 border-radius属性用于设置元素的外边框圆角 1border-radius: \"length\"; ** 自定义倒圆角的半径","text":"盒子模型圆角边框在CSS3中，新增了圆角边框样式，使盒子可以变成圆角 border-radius属性用于设置元素的外边框圆角 1border-radius: \"length\"; ** 自定义倒圆角的半径 radius半径原理：椭圆与边框的交集形成圆角效果 参数值可以为数值或百分比的形式 如果是正方形，想设置一个圆，把数值修改为高度或宽度的一半即可，或者直接写50% 如果是个矩形，设置为高度的一半就可以做圆角矩形 该属性是简写，可以写四个数值，分别代表左上角、右上角、右下角、左下角 盒子阴影CSS3新增了盒子阴影，使用box-shadow属性为盒子添加阴影 1box-shadow: h-shadow b-shadow blur spread color inset; 值 描述 h-shadow 必需，水平阴影的位置，允许负值 v-shadow 必需，垂直阴影的位置，允许负值 blur 可选，模糊距离 spread 可选，阴影尺寸 color 可选，阴影颜色 常用半透明 rgba(0, 0, 0, .3) inset 可选，将外部阴影（outset）改为内部阴影 注意： 默认的是外阴影（outset），但是不可以写这个单词，否则导致阴影无效 盒子阴影不占空间，不影响其他盒子排序 文字阴影CSS3中，可以使用text-shadow属性将阴影应用于文本 1text-shadow: h-shadow v-shadow blur color; 值 描述 h-shadow 必需，水平阴影位置 v-shadow 必需，垂直阴影的位置 blur 可选，模糊的距离 color 可选，阴影的颜色","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"4-盒子模型1","slug":"4-盒子模型1","date":"2020-07-09T13:39:43.805Z","updated":"2020-07-10T00:33:00.567Z","comments":true,"path":"2020/07/09/4-盒子模型1/","link":"","permalink":"http://yoursite.com/2020/07/09/4-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B1/","excerpt":"盒子模型盒子模型组成盒子模型：把HTML页面中的布局元素看作一个矩形的盒子，CSS盒子模型本质是一个盒子封装周围的HTML元素，包括：边框、外边距、内边距、实际内容","text":"盒子模型盒子模型组成盒子模型：把HTML页面中的布局元素看作一个矩形的盒子，CSS盒子模型本质是一个盒子封装周围的HTML元素，包括：边框、外边距、内边距、实际内容 边框 属性 属性值 作用 border-width 定义边框粗细，单位是px border-style solid 实线边框dashed 虚线边框dotted 点线边框 边框的样式 border-color 边框颜色 边框复合写法边框简写： 1border: 1px solid red; 没有顺序 边框分开写法： 12border-top: 1px solid red; 只设定上边框border-bottom: 3px dashed bule; 只设定下边框 表格的细线边框border-collapse属性控制浏览器绘制表格边框的方式，控制相邻单元格的边框 1border-collapse: collapse; 表示相邻边框合并在一起 内边距padding属性用于设置内边距，即边框与内容之间的距离 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 简写 值的个数 表达意思 padding: 5px 1个值，代表上下左右都有5px内边距 padding: 5px 10px 2个值，代表上下内边距5px，左右内边距10px padding: 5px 10px 20px 3个值，代表上内边距5px，左右内边距10px，下内边距20px padding: 5px 10px 20px 30px 4个值，上是5px 右是10px 下是20px 左是30px*** 顺时针 外边距margin 属性用于设置外边距，即控制盒子和盒子之间的距离 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 简写方式与内边距一样 外边距典型应用外边距可以让块级盒子水平居中，但是必须满足两个条件： 盒子必须指定了宽度（width） 盒子左右外边距都设置为auto 常见写法： margin-left: auto; margin-right: auto; margin: auto; **上下左右auto margin: 0 auto; **上下为0，左右auto 注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加text-align: center 即可 嵌套块元素垂直外边距的塌陷对于两个嵌套元素（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值 解决方案： 可以为父元素定义上边框 可以为父元素定义上内边距 可以为父元素添加 overflow: hidden; 清除内外边距网页元素很多带有默认的内外边距，而且不同浏览器默认的也不一致，因此布局前，首先要清除下网页元素的内外边距 1234* &#123; padding: 0; **清除内边距 margin: 0; **清除外边距&#125; 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距，但是转换为块级和行内块元素就可以了","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"不知名胡话","slug":"不知名胡话","date":"2020-07-09T13:24:00.000Z","updated":"2020-07-15T13:19:13.243Z","comments":true,"path":"2020/07/09/不知名胡话/","link":"","permalink":"http://yoursite.com/2020/07/09/%E4%B8%8D%E7%9F%A5%E5%90%8D%E8%83%A1%E8%AF%9D/","excerpt":"","text":"7月9日 大风​ 这两天去打听健身房，选了个有游泳池的，本来准备今天办卡，说是11号有活动，所以自然而然就打算等到11号再去吧。 ​ 其实本身也很纠结，当然健身是必须的，不过到底去健身房有没有必要呢？——虽然我在家里也不会主动健身，大概也是希望人群效应能提醒自己不要懒散了。 ​ 如果说现阶段的焦虑，那当然不光是体型——虽然现在有点超重，阿西吧——还有就业之类的，虽然意向是Java后端，但事实上原本最初的梦想是去游戏公司做游戏开发，当然是大头公司啦，像是暴雪之类的。不过随着现实的深入，也越发觉得无望——听说Java简单点，就业也容易，所以就转来学Java。不过现在学前端，缺越发离初心遥远了。 ​ 我也不知道未来会怎么样，只是每次夜深人静时想像起死亡的时候，在生命弥留之际时的感觉，越发觉得恐怖。在很久以前我就在思考这种感觉，然后恐怖 ，想象，然后恐怖……这样周而复始，最后得出了——好好享受这几十年的人生吧！——这样的结论。而现在，我二十三岁了，已经是人生的四分之一，说来究竟是快呢还是慢呢？这二十多年有没有好好留下我存在过的证明呢？其实最后，也改变不了时间。伟人会在历史的车轱辘上留下名字，而其他所有人，只是世界存在中诞生的一粒尘埃，宇宙浩渺，世界浩大，国家庞大，一个人要怎么名垂青史呢？不容易。我也不想试图去做，只要安乐过完这一生，便好♥ ​ 爱我爱的人，爱爱我的人♥感念","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"胡话笔记","slug":"胡话笔记","permalink":"http://yoursite.com/tags/%E8%83%A1%E8%AF%9D%E7%AC%94%E8%AE%B0/"}]},{"title":"3-CSS2","slug":"3-CSS2","date":"2020-07-08T15:40:04.036Z","updated":"2020-07-23T03:49:28.354Z","comments":true,"path":"2020/07/08/3-CSS2/","link":"","permalink":"http://yoursite.com/2020/07/08/3-CSS2/","excerpt":"","text":"CSSEmmet语法Emmet语法的前身是Zen coding，它使用缩写来提高html/css的编写速度，VScode内部已经集成该语法。 快速生成HTML结构语法 生成标签 直接输入标签名后按Tab键即可，比如div按tab，生成《div》《/div》 如果想生成多个相同标签 加上就可以了，比如div*3 如果有父子级关系的标签，可以用&gt; 比如ul&gt;li就可以了 如果有兄弟关系的标签，用+就可以了 比如div+p 如果生成带有类名或者id名字的，直接写 .demo或者 #two Tab键就可以了 如果生成的div类名是有顺序的，可以用自增符号$配合，比如 .demo$*5 按Tab键 如果想要在生成的标签内部写内容可以用{ }表示，比如 div{内容} 按Tab键 快速生成CSS样式语法CSS基本采取简写形式即可： 比如w200 按Tab 可以生成 width: 200px; 比如lh26 按Tab 可以生成 line-height: 26px; 快速格式化代码VScode右键点击格式化文档/shift+alt+F即可 也可以设置保存页面时自动格式化代码： 文件——》【首选项】——》【设置】 搜索emmet.include; 在setting.json下的【用户】中添加以下语句：“editor.formatOnType”: true,“editor.formatOnSave”: true 只需设置一次，以后都可以自动保存格式化代码 CSS的复合选择器复合选择器建立在基础选择器之上，对基础选择器进行组合形成的 复合选择器可以更准确、高效地选择目标元素（标签） 复合选择器是由两个或多个基础选择器，通过不同方式组合而成的 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器 后代选择器后代选择器（包含选择器）可以选择父元素里面的子元素，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔，当标签发生嵌套时，内层标签就成为外层标签的后代 12元素1 元素2 &#123; 样式声明 &#125;**表示选择元素1里面的所有元素2** 元素1和元素2中间用空格隔开 元素1是父级，元素2是子级，最终选择的是元素2 元素1和元素2可以是任意基础选择器 子元素选择器子元素选择器（子选择器）只能选择作为某一元素的最近一级子元素。简单理解就是选亲儿子元素 12元素1 &gt; 元素2 &#123; 样式声明 &#125;** 选择元素1里面的所有直接后代（子元素）元素2 ** 元素1和元素2中间用大于号隔开 元素1 是父级，元素2是子级，最终选择的是元素2 元素2必须是亲儿子 并集选择器并集选择器可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明 并集选择器是各选择器通过英文逗号（, ）连接而成，任何形式的选择器都可以作为并集选择器的一部分 12元素1 , 元素2 &#123; 样式声明 &#125;** 选择元素1和元素2 ** 注意：最后一个选择器不需要加逗号 伪类选择器伪类选择器用于向某些选择器添加特殊效果，比如给链接添加特殊效果，或选择第1个，第n个元素 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover、 :fist-child 链接伪类选择器1234a:link /* 选择所有未被访问的链接 */a:visit /* 选择所有已被访问的链接 */a:hover /* 选择鼠标指针位于其上的链接 */a:active /* 选择活动链接（鼠标按下未弹起的链接） */ 注意事项： 为了确保生效，按照LVHA的循顺序声明 :link - :visited - :hover - :active 记忆法：love hate或者lv 包包 hao 因为a链接在浏览器中具有默认样式，所以实际工作中都需要给链接单独指定样式 链接伪类选择器实际工作中的写法： 12345678910/* 链接正常状态下 */a &#123; color: #333; text-decoration: none;&#125;/* 鼠标悬停在链接时 */a:hover &#123; color: #369; text-decoration: underline; &#125; :focus伪类选择器:focus 伪类选择器用于选取获得焦点的表单元素 焦点就是光标，一般情况《input》类表单元素才能获取，因此这个选择器也主要针对表单元素来说 123input:focus&#123; background-color: yellow;&#125; 总结 选择器 作用 特征 隔开符号及用法 后代选择器 选择后代元素 可以是子孙后代 符号是空格 .nav a 子代选择器 选择最近一级元素 只选亲儿子 符号是大于 .nav&gt;p 并集选择器 选择某些相同样式的元素 可以用于集体声明 符号是逗号 链接伪类选择器 选择不同状态的链接 跟链接相关 重点记住a{ }和a:hover实际开发写法 :focus 选择获得光标的表单 跟表单相关 input:focus记住这个写法 CSS元素显示模式元素显示模式就是元素（标签）以什么方式进行显示 HTML一般分为块元素和行内元素 块元素常见块元素有《h1》-《h6》、《p》、《div》、《ul》、《ol》、《li》 块元素的特点： 自己独占一行 高度、宽度、外边距、内边距都可以控制 宽度默认是容器的100% 是一个容器及盒子，里面可以放行内或者块级元素 注意： 文字类的元素内不能使用块级元素 《p》标签主要用于存放文字，因此《p》里面不能放块级元素，特别是不能放《div》 同理，《h1-h6》都是文字类块级标签，里面不能放其他块级元素 行内元素常见的行内元素有《a》、《strong》、《b》、《em》、《i》、《del》、《s》、《ins》、《u》、《span》等，也成为内联元素 行内元素特点： 相邻行内元素在一行上，一行可以显多个 高、宽直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或者其他行内元素 注意： 链接里面不能放链接 特殊情况链接a里面可以放块级元素，但是给《a》转换一下块级模式最安全 行内块元素在行内元素中有几个特殊的标签，《img/》、《input/》、《td》，它们同时具有块元素和行内元素的特点，有些资料称它们为行内块元素 行内块元素特点： 和相邻行内元素（行内块）在一行上，但是它们之间有空白缝隙，一行可以显示多个 默认宽度就是它本身内容的宽度 高度、行高、外边距以及内边距都可以控制 总结 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽高 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽高 本身内容的宽度 容纳文本或其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽高 本身内容的宽度 元素显示模式的转换特殊情况下，需要元素模式的转换，一个模式的元素需要另外一种模式的特性，比如想要增加链接《a》的触发范围 转换为块元素：display: block; 转换为行内元素：display: inline; 转换为行内块：display: inline-block; 小技巧——单行文字垂直居中的代码CSS没有提供文字垂直居中的代码，但是可以通过： 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中 12line-height=\"height\";** 引号中的height为用户定义的盒子高度数值** CSS的背景通过CSS背景属性，可以给页面元素添加背景样式 背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等 背景颜色background-color定义元素背景颜色，一般默认为transparent（透明） 背景图片background-image描述元素的背景图片，实际开发常见于logo或者装饰性的小图片，超大背景图，优点是便于控制位置 12backgroud-image: url(\"URL\");** 不要落下 url() ** 背景平铺background-repeat对背景图像进行平铺 属性值 描述 repeat 背景图在纵向和横向上平铺（重复）【默认值】 no-repeat 背景图不平铺 repeat-x 在横向上平铺 repeat-y 在纵向平铺 背景图片位置background-position属性改变图片在背景中的位置 12background-position: x y;** x坐标和y坐标，可以使用方位名词或者精确单位 ** 参数值 说明 length 百分数|由浮点数和单位标识符组成的长度值 position X坐标：left | center | right Y坐标：top | center | bottom 【方位名词】 参数是方位名词 如果指定的两个值都是方位名词，则两个值前后顺序无关 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 参数是精确单位 如果参数值是精确坐标，那么第一个值一定是X坐标，第二个值一定是Y坐标 如果只指定一个数值，那该数值一定是X坐标，另一个默认垂直居中 参数是混合单位 如果指定的两个值是精确单位和方位名词混合使用，则第一个是X坐标，第二个是Y坐标 背景图像固定（背景附着）background-attachment属性设置背景图是否固定或者随着页面的其余部分滚动，后期可制作视差滚动的效果 参数值 作用 scroll 背景图像随对象内容滚动 fixed 背景图像固定 背景复合写法为了简化背景属性的代码，可以将这些属性合并简写在同一个属性background中，当使用简写属性时，没有特定的书写顺序，一般约定顺序为： background：背景颜色 背景图片 背景平铺 背景图像滚动 背景图片位置 背景色半透明CSS3提供了背景颜色半透明的效果： 12background: rgba(0, 0, 0, 0.3);** 前三个为RGB取色 ** 最后一个参数是alpha透明度，取值在0~1之间 习惯把0.3的0省略掉，写为background：rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明，盒子里的内容不受影响 CSS3新增属性，是IE9+版本浏览器才支持的 CSS三大特性层叠性相同选择器给设置相同的样式，此时一个样式会覆盖（层叠）另一个冲突的样式，层叠性主要解决样式冲突问题 层叠性原则； 样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 继承性CSS中，子标签会继承父标签的某些样式 优先级（权重叠加）当同一个元素指定多个选择器，就会产生优先级 选择器相同，则执行层叠性 选择器不同，则根据选择器权重执行 选择器 权重 继承或者* 0，0，0，0 伪元素选择器、元素选择器 0，0，0，1 类选择器、属性选择器、伪类选择器 0，0，1，0 ID选择器 0，1，0，0 行内样式 style=“” 1，0，0，0 ！important 重要的 ∞ 无穷大 权重叠加： 如果是复合选择器，则会有权重叠加，需要计算权重 注意：类选择器、属性选择器、伪类选择器，权重为10 CSS属性书写顺序建议遵循： 布局定位属性：display / position / float / clear / visibility / overflow 建议display第一个写，关系到模式 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"3-CSS1","slug":"3-CSS1","date":"2020-07-08T02:37:18.982Z","updated":"2020-07-08T02:39:38.409Z","comments":true,"path":"2020/07/08/3-CSS1/","link":"","permalink":"http://yoursite.com/2020/07/08/3-CSS1/","excerpt":"CSSCSS是层叠样式表（Cascading Style Sheets）的简称，也是一种标记语言 CSS主要用于设置HTML页面的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式 CSS语法规范CSS规则由两个主要部分：选择器以及一条或多条声明 123456&lt;style&gt; p (选择器)&#123; color: red;(声明) font-size: 25px; &#125;&lt;/style&gt;","text":"CSSCSS是层叠样式表（Cascading Style Sheets）的简称，也是一种标记语言 CSS主要用于设置HTML页面的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式 CSS语法规范CSS规则由两个主要部分：选择器以及一条或多条声明 123456&lt;style&gt; p (选择器)&#123; color: red;(声明) font-size: 25px; &#125;&lt;/style&gt; 选择器是用于指定CSS样式的HTML标签，花括号内是对该对象设置的具体样式 声明中的属性和属性值以键值对的形式出现 属性是对指定对象设置的样式属性，如字体大小、文本颜色 属性和属性值之间用英文“:”分开 多个键值对之间用英文“;”分开 CSS代码风格空格规范 123456&lt;style&gt; p (选择器)&#123; color: red;(声明) font-size: 25px; &#125;&lt;/style&gt; 属性值前面，冒号后面，保留一个空格 选择器和大括号中间保留空格 选择器分类选择器分为基础选择器和复合选择器两类 基础选择器 基础选择器由单个选择器组成 其中包括：标签选择器、类选择器、id选择器、通配符选择器 标签选择器标签选择器（元素选择器）指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式 作用 标签选择器可以把某一类标签全部选中，比如所有《div》和所有《span》 优点 能快速为页面中同一类型的标签统一设置样式 缺点 不能设计差异化样式，只能选择全部的当前标签 类选择器如果想要差异化选择不同的标签，单独选一个或者几个标签，可以使用类选择器 1234.类型&#123; 属性1: 属性值1; ……&#125; *在类名前有一个“ . ” * 结构需要用calss属性来调用class类的意思 123&lt;div class='用户自定义类名'&gt; 内容&lt;/div&gt; 类选择器-多类名给一个标签指定多个类名，从而达到更多的选择目的，这些类名都可以选出这个标签，即一个标签有多个名字 多类名使用方式123&lt;div class='red font20'&gt; 亚瑟&lt;/div&gt; 在标签class属性中写多个类名 多个类名中间用空格分开 使用场景 可以把一些标签元素相同的样式（共同的部分）放在一个类里 这些标签都可以调用这个公共的类，然后调用自己独有的类 从而节省CSS代码，统一修改 id选择器HTML元素以id属性来设置id选择器，CSS中id选择器以“#”来定义 id选择器和类选择器的区别: 类选择器（class）好比人的名字，一个人可以有多个名字，一个名字可以被多个人使用 id选择器好比人的身份证号码，唯一使用，不能重复 id选择器和类选择器最大的不同在于使用次数 类选择器在修改样式中用的最多，id选择器一般用于页面唯一性的元素上，常和JavaScript搭配使用 通配符选择器在CSS中，通配符选择器使用“*”定义，表示选取页面中的所有元素（标签） 1234*&#123; 属性1: 属性值1; ……&#125; 通配符选择器不需要调用 特殊情况才使用 总结 基础选择器 作用 特点 使用情况 用法 标签选择器 可以选出所有相同的标签 不能差异化选择 较多 p{color: red;} 类选择器 可以选出1个或多个标签 可以根据需求选择 非常多 .nav{color: red;} id选择器 一次只能选择1个标签 ID属性只能在每个HTML文档中出现一次 一般和JS搭配 #nav{color: red;} 通配符选择器 选择所有标签 选择的太多，有部分不需要 特殊情况使用 *{color: red;} CSS字体属性CSS Fonts属性用于定义字体系列、大小、粗细和文字样式 字体系列CSS使用font-family属性定义文本的字体系列 123p&#123; font-family: \"Microsoft YaHei\", tahoma, arial;&#125; 各个字体之间必须使用英文状态下的逗号隔开 一般情况下，如果有空格隔开的多个单词组成的字体，加引号 尽量使用系统默认自带字体 当定义多个字体时，浏览器依次读取，并取第一个系统带有的字体 字体大小CSS使用font-size属性定义字体大小 123p&#123; font-size: 20px;&#125; px(像素)大小是网页常用单位 谷歌浏览器默认字体大小为16px 不同浏览器默认显示字体大小可能不同，尽量给一个明确的值 可以给body指定整个页面内容的字体大小 标题标签（h1-h6）需要单独指定文字大小 字体粗细CSS使用font-weight属性设置文字粗细 123p&#123; font-weight: bold;&#125; 属性值 描述 normal 默认值（不加粗） bold 定义粗体 100-900 400等同于normal，700等同于bold，注意数字后面不跟单位 文字样式CSS使用font-style属性设置文本的风格 123p&#123; font-style: normal;&#125; 属性值 作用 normal 默认值。显示标准字体样式 italic 显示斜体样式 注意： 平时很少给字体加斜体，反而要给斜体标签（em，i）改为不倾斜 字体复合属性字体属性可以把以上文字样式综合起来，节约代码 123body&#123; font: font-style font-weight font-size/line-height font-family;&#125; 123body&#123; font: italic 700 16px 'Microsoft YaHei';&#125; 注意： 使用font属性时，必须按照以上语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开 不需要设置的属性可以省略，但必须保留font-size和font-family属性，否则font属性将不起作用 总结 属性 表示 注意 font-size 字号 通常用的单位是px像素，一定要跟上单位 font-family 字体 按照团队约定来写字体 font-weight 粗细 加粗是700或者bold不加粗是400或者normal数字不跟单位 font-style 样式 倾斜是italic，不倾斜是normal font 复合 1.有顺序，不能更改顺序 2.其中字号和字体必须同时出现 文本属性CSS Text（文本）属性可定义文本的外观（颜色、对齐、装饰、缩进、行间距） 文本颜色color属性定义文本的颜色 表示 属性值 预定义的颜色值 red, green, blue, pink 十六进制 #FF0000, #FF6600, #29D794 RGB代码 rgb(255,0,0)或者rgb(100%,0%,0%) 常用十六进制 对齐文本text-align属性设置元素内文本内容的水平对齐方式 属性值 解释 left 左对齐（默认） right 右对齐 center 居中对齐 装饰文本text-decoration属性规定添加到文本的装饰，可以给文本添加下划线、删除线、上划线 属性值 描述 none 默认，无装饰线 underline 下划线，链接a自带下划线 overline 上划线 line-through 删除线 可在链接a的属性中用none删除下划线 文本缩进text-indent属性用来指定文本的第一行的缩进，通常将段落的首行缩进 123p&#123; text-indent: 2em;&#125; em是一个相对单位，就说当前元素（font-size）1个文字大小，如果当前元素没有设置大小，则会按照父元素的1个文字大小 行间距line-height属性设置行间的距离 行间距=上间距+文本高度+下间距 总结 属性 表示 注意 color 颜色 通常用十六进制 text-align 对齐 设定文字水平的对齐方式 text-indent 缩进 通常用于段落首行缩进2个字的距离，2em text-decoration 装饰 下划线 underline 取消下划线 none line-height 行高 控制行与行之间的距离 CSS的引用方式内部样式表（内嵌式）写到HTML页面内部，将所有CSS代码抽取出来，单独放到一个《style》标签中 123456&lt;style&gt; div&#123; color: red; &#125; ……&lt;/style&gt; 《style》标签理论上可以放在HTML文档的任何地方，但一般会放在文档的《head》标签中 控制当前HTML页面的样式 行内样式表（内联式）是在元素标签内部的sytle属性中设定CSS样式，适合修改简单样式 123&lt;p sytle='color: red; font-size: 20px;'&gt; 内容&lt;/p&gt; style其实就说标签的属性 在引号中间，写法要符合CSS规范 可以控制当前标签样式 外部样式表样式单独写到CSS文件中，之后把CSS文件引入到HTML页面 引入外部样式表分为两步： 新建一个后缀名为 .css的样式文件，把所有CSS代码放入此文件中 在HTML页面中，使用《link》标签引入这个文件 1&lt;link rel='stylesheet' href='css文件路径' 属性 作用 rel 定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件 href 定义所链接外部样式表文件的URL，可以是相对路径也可以是绝对路径 Chrome调试工具打开调试工具打开Chrome浏览器，按下F12键或者右击页面空白处-&gt;检查 使用调试工具 Ctrl+滚轮可以放大开发者工具代码大小 左边是HTML元素结构，右边是CSS样式 右边CSS样式可以改动数值和查看颜色 Ctrl+0 复原浏览器大小 如果点击元素，发现右边没有样式引入，极有可能是类名或者样式引入错误 如果有样式，但样式前面有黄色感叹号，则是样式属性书写错误","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"2-Html标签3","slug":"2-Html标签3","date":"2020-07-07T12:08:43.348Z","updated":"2020-07-08T02:42:05.650Z","comments":true,"path":"2020/07/07/2-Html标签3/","link":"","permalink":"http://yoursite.com/2020/07/07/2-Html%E6%A0%87%E7%AD%BE3/","excerpt":"HTMl基本标签表格标签基本语法1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; …… &lt;/tr&gt; ……&lt;/table&gt;","text":"HTMl基本标签表格标签基本语法1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; …… &lt;/tr&gt; ……&lt;/table&gt; 《table》《/table》是用于定义表格的标签 《tr》《/tr》定义表格中的行，必须嵌套在table中 《td》《/td》定义表格中的单元格，必须嵌套在tr中 表头单元格标签《th》标签表示HTML表格的表头部分，文本内容加粗居中显示 表格属性 属性名 属性值 描述 align left、center、right 规定表格相对周围元素的对齐方式 border 1或者“ ” 表格单元是否拥有边框，默认为“”无边框 cellpadding 像素值 单元边沿与其内容之间的空白，默认1px cellspacing 像素值 单元格之间的空白，默认2px width 像素值或百分比 表格的宽度 表格结构标签表格可能很长，为了更好的表示表格的语义，将表格分为头部和主体 《thead》标签 == 表格的头部区域 《tbody》标签 == 表格的主体区域 合并单元格合并单元格方式 跨行合并：rowspan=’合并单元格的个数’ 跨列合并：colspan=’合并单元格的个数’ 目标单元格 跨行：最上侧单元格为目标单元格 跨列：最左侧单元格为目标单元格 合并步骤 先确定是跨行还是跨列 找到目标单元格，写上合并方式=合并的单元格数量。 删除多余的单元格 列表标签列表用来布局，列表的特点是整齐、整洁、有序 列表分为三类：无序列表、有序列表、自定义列表 无序列表《ul》标签表示无序列表，一般会以项目符号呈现列表项，而列表项用《li》定义 12345&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; ……&lt;/ul&gt; 无序列表各个列表项没有顺序级别，是并列的 《ul》《/ul》中只能嵌套《li》《/li》，不能输入其他标签或者文字 《li》《/li》相当于一个容器，里面可以存放所有元素 无序列表带有自己的样式属性 有序列表《ol》标签定义有序列表，列表排序以数字显示，且使用《li》标签定义列表项 12345&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; ……&lt;/ol&gt; 自定义列表自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号 《dl》标签定义描述列表，该标签会与《dt》（定义项目/名字）和《dd》（描述每个项目/名字）一起使用 123456&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ……&lt;/dl&gt; 表单标签表单的目的是为了收集用户信息 表单的组成在HTML中，一个完整的表单通常由表单域、表单控件（表单元素）和提示信息构成 表单域一个包含表单元素的区域 在HTML标签中，《from》标签用于定义表单域，以实现用户信息的收集和传递 《from》会把它范围内的表单元素信息提交给服务器 123&lt;from action='URL地址' method='提交方式' name='表单域名称'&gt; 各种表单控件&lt;/from&gt; 属性 属性值 作用 action URL地址 指定接收并处理表单数据的服务器程序的URL地址 method get/post 设置表单数据的提交方式 name 名称 指定表单的名称，以区分同一个页面中的多个表单域 表单控件（表单元素）《input》表单元素用于收集用户信息 在《input》标签中，包含一个type属性，根据不同的type属性值，输入的字段拥有很多种形式（文本、复选框、单选按钮、按钮等） 1&lt;input type='属性值' /&gt; 属性值 描述 button 可点击按钮（多数情况下用于通过JavaScript启动脚本 checkbox 复选框 file 输入字段和“浏览”按钮，供文件上传 hidden 隐藏的输入字段 image 图像形式的提交按钮 password 密码字段，字符被掩码 radio 单选按钮 reset 重置按钮，清除表单中的所有数据 submit 提交按钮，把表单数据发送到服务器 text 单行的输入字段，可在其中输入文本，默认宽度20个字符 除type属性外，《input》标签有其他属性： 属性 属性值 描述 name 由用户定义 定义input元素的名称 value 由用户定义 规定input的值 placeholder 由用户定义 在文本框中显示提示信息 checked checked 规定此input元素首次加载时应当被选中 maxlength 正整数 规定输入字段中的字符的最大长度 注意： name和value是每个表单元素都有的属性值，主要给后台人员使用 name表单元素的名字，要求单选按钮和复选框要有相同的name值 checked属性主要针对单选按钮和复选框，打开页面时默认选中某个表单元素 maxlength是用户可以在表单元素输入的最大字符数，一般较少使用 label标签《label》标签为input元素定义标注（标签） 《label》标签用于绑定一个表单元素，当点击《label》标签内的文本时，浏览器会自动将焦点（光标）转到或者选择对应的表单元素上，增加用户体验 12&lt;label for='sex'&gt; 男 &lt;/label&gt;&lt;input type='radio' name='sex' id='sex' /&gt; 核心：《label》标签的for属性应当与相关元素的id属性相同 《select》表单元素如果有多个选项，想节约空间时，可使用《select》标签控件定义下拉列表 1234567&lt;select&gt; &lt;option&gt; 选项1 &lt;/option&gt; &lt;option&gt; 选项2 &lt;/option&gt; &lt;option&gt; 选项3 &lt;/option&gt; &lt;option&gt; 选项4 &lt;/option&gt; ……&lt;/select&gt; 注意： 《select》中至少包含一对《option》 在《option》中定义selected=“select”时，当前项即为默认选中项 《textarea》表单元素当用户输入内容较多的情况下，可使用文本域《text area》定义多行文本输入的控件 使用多行文本输入控件，可以输入更多文字，常见于留言板、评论 123&lt;textarea rows='3' cols='20'&gt; 文本内容&lt;/textarea&gt; 查阅文档W3C：http://www.w3school.com.cn/ 点击下载 下载 下载 MDN：https://developer.mozilla.org/zh-CN/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"2-Html标签2","slug":"2-Html标签2","date":"2020-07-06T10:21:59.158Z","updated":"2020-07-16T12:12:11.588Z","comments":true,"path":"2020/07/06/2-Html标签2/","link":"","permalink":"http://yoursite.com/2020/07/06/2-Html%E6%A0%87%E7%AD%BE2/","excerpt":"","text":"HTML常用标签图像标签和路径在HTML标签中，《img》标签用于定义HTML页面中的图像。单标签 1&lt;img src='图像URL' /&gt; src是《img》标签的必须属性，用于指定图像文件的途径和文件名 属性 属性值 说明 src 图片路径 必须熟悉 alt 文本 替换文本，图像不能显示时显示的文字 title 文本 提示文本，鼠标放在图像上，显示的文字 width 像素 设置图像的宽度 height 像素 设置图像高度 border 像素 设置图像的边框粗细 注意： 图像属性必须写在标签名后面 属性不分先后顺序，属性之间空格分隔 属性采取键值对格式，属性=“属性值” 路径相对路径以引用文件所在位置为参考基础，建立的目录路径，即图片相对于HTML文件的位置 相对路径分类 符合 说明 同一级 图像位于HTML文件同一级 下一级 / 图像位于HTML文件下一级，《img src=’images/baidu,jpg’》 上一级 ../ 图像位于HTML上一级 绝对路径指目录下的绝对位置，通常从盘符开始的路径 “D:\\web\\img\\logo.gif” 或者”https://www.baidu.com/images/logo.gif&quot; 超链接标签《a》从一个页面链接到另一个页面 1&lt;a href='跳转目标' target='目标窗口弹出方式'&gt;文本或图像&lt;/a&gt; 当不想让a标签跳转时 12&lt;a href=\"javascript:;\"&gt;&lt;/a&gt; 不跳转仍在本页面&lt;a href=\"javascript:void(0);\"&gt;&lt;/a&gt; href属性值为”javascript:;”时，不会跳转 属性 作用 href 指定链接目标的URL地址，必须属性 target 指定打开方式，_self为默认值___blank为在新窗口中打开 锚点链接 在链接文本的herf属性中，设置属性值为#名字的形式，如： &lt;a herf='#two'&gt;click&lt;/a&gt; 1234567* 找到目标位置标签，里面添加一个**id属性&#x3D;刚才的名字**，如：* ~~~html &lt;h3 id&#x3D;&#39;two&#39;&gt; show up &lt;&#x2F;h3&gt; 注释HTML中注释以“《!–”开头，以“–》”结束 特殊字符","categories":[],"tags":[]},{"title":"1-Web标准","slug":"1-Web标准","date":"2020-07-06T08:18:07.639Z","updated":"2020-07-08T02:41:38.356Z","comments":true,"path":"2020/07/06/1-Web标准/","link":"","permalink":"http://yoursite.com/2020/07/06/1-Web%E6%A0%87%E5%87%86/","excerpt":"Web标准由W3C组织（万维网联盟）制定 1、为什么需要标准​ 浏览器不同，显示页面或者排版有差异 ​ 更容易被搜寻引擎搜索 ​ 降低网站流量费用 ​ 使网站易于维护 ​ 提高页面浏览速度","text":"Web标准由W3C组织（万维网联盟）制定 1、为什么需要标准​ 浏览器不同，显示页面或者排版有差异 ​ 更容易被搜寻引擎搜索 ​ 降低网站流量费用 ​ 使网站易于维护 ​ 提高页面浏览速度 2、Web标准的构成主要包括结构、表现、行为 标准 说明 结构 结构用于对网页元素进行整理和分类，主要学习HTML 表现 表现用于设置网页元素的版式、颜色、大小，主要指CSS 行为 行为指网页模型的定义以及交互的编写，主要学习JavaScript Web标准提出的最佳方案：结构、样式、行为相分离S 结构写在HTML文件中，表现写在CSS文件中，行为写在JavaScript文件中","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"2-Html标签","slug":"2-Html标签","date":"2020-07-06T08:18:07.639Z","updated":"2020-07-08T02:41:48.775Z","comments":true,"path":"2020/07/06/2-Html标签/","link":"","permalink":"http://yoursite.com/2020/07/06/2-Html%E6%A0%87%E7%AD%BE/","excerpt":"HTML标签HTML语法规范 HTML标签是由&lt;&gt;（尖括号）包围的关键词中 大部分标签成对存在，eg. 有些特殊的单标签 双标签可分为两类：包含关系和并列关系 标签名 定义 说明 HTML标签 页面内最大的标签，根标签 文档的头部 在head标签中必须要设置的标签是title 文档的标题 让页面拥有属于自己的网页标题 文档的主体 元素包含文档的所有内容","text":"HTML标签HTML语法规范 HTML标签是由&lt;&gt;（尖括号）包围的关键词中 大部分标签成对存在，eg. 有些特殊的单标签 双标签可分为两类：包含关系和并列关系 标签名 定义 说明 HTML标签 页面内最大的标签，根标签 文档的头部 在head标签中必须要设置的标签是title 文档的标题 让页面拥有属于自己的网页标题 文档的主体 元素包含文档的所有内容 DOCTYPE、lang以及字符集的作用1、文档类型声明标签​ &lt;!DOCTYPE&gt;文档类型声明标签，作用是告诉浏览器使用哪种HTML版本来显示网页 1&lt;!DOCTYPE html&gt; 这句代码的意思：当前页面采用的是HTML5版本显示 注意： 《!DOCTYPE》声明位于文档中的第一行 《!DOCTYPE》不是一个HTML标签 2、lang语言种类用来定义当前文档显示的语言 en定义语言为英语 zh-CN定义语言为中文 简单来说，定义为en就是英文网页，定义为zh-CN就是中文网页 其实对文档显示来说，定义为en的文档也可以显示中文，反之相同，lang定义是对浏览器和搜索引擎作用的。 3、字符集字符集（Character set）是多个字符的集合，以便于计算机识别和存储各种文字。 在《head》标签内，可以通过《meta》标签的charset属性来规定HTML文档应该使用哪种字符编码。 1&lt;meta charset='UTF-8' /&gt; charset常用的值有：GB2312、BIG5、GBK和UTF-8，其中UTF-8被称为万国码，基本包含了世界所有国家需要用到的字符。 注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用‘UTF-8’编码。 HTML常用标签标签语义根据标签的语义，在合适的地方给一个合理的标签，可以让页面结构清晰。 标题标签为了使网页具有语义化，HTML提供6个等级的网页标题：《h1》-《h6》 语义：作为标题使用，且依据重要性递减 特点： 加了标题的文字会变粗，字号依次变大 一个标题独占一行 段落标签和换行标签《p》标签用于定义段落 语义：可以把HTML文档分割为若干段落 特点： 文本在段落中会根据浏览器窗口大小自动换行 段落之间保有空隙 《br /》标签用于强制换行 特点 《br /》是单标签 只是换行，没有段落空隙 文本格式化标签 语义 标签 说明 加粗 《strong》《/strong》或《b》《/b》 更推荐《strong》标签 倾斜 《em》或者《i》 更推荐《em》 删除线 《del》或者《s》 更推荐《del》 下划线 《ins》或者《u》 更推荐《ins》 《div》和《span》标签没有语义，作为盒子装内容。 division-分割 span-跨度、跨距 特点： 《div》标签用来布局，一行只能放一个 《span》标签用来布局，一行可以放多个","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"test","slug":"testtest","date":"2017-07-07T14:55:45.000Z","updated":"2020-07-15T13:19:24.584Z","comments":true,"path":"2017/07/07/testtest/","link":"","permalink":"http://yoursite.com/2017/07/07/testtest/","excerpt":"","text":"为什么归档打不开了！！","categories":[],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"扩展知识","slug":"扩展知识","permalink":"http://yoursite.com/categories/%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"},{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"私有前缀","slug":"私有前缀","permalink":"http://yoursite.com/tags/%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80/"},{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"},{"name":"特效","slug":"特效","permalink":"http://yoursite.com/tags/%E7%89%B9%E6%95%88/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"曾经犯的错误","slug":"曾经犯的错误","permalink":"http://yoursite.com/tags/%E6%9B%BE%E7%BB%8F%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"},{"name":"无题","slug":"无题","permalink":"http://yoursite.com/tags/%E6%97%A0%E9%A2%98/"},{"name":"胡话笔记","slug":"胡话笔记","permalink":"http://yoursite.com/tags/%E8%83%A1%E8%AF%9D%E7%AC%94%E8%AE%B0/"},{"name":"APIs","slug":"APIs","permalink":"http://yoursite.com/tags/APIs/"},{"name":"布局页面","slug":"布局页面","permalink":"http://yoursite.com/tags/%E5%B8%83%E5%B1%80%E9%A1%B5%E9%9D%A2/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]}